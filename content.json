{"meta":{"title":"Zhou","subtitle":null,"description":"好少年光芒万丈","author":"Zhou","url":""},"pages":[{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-04-18T11:47:51.151Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-04-18T11:47:51.151Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-04-18T11:47:51.152Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-04-18T11:47:51.152Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-04-21T06:29:21.907Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-04-18T11:47:51.150Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-04-18T11:47:51.154Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-04-18T11:47:51.153Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-04-18T11:47:51.154Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-04-18T11:47:51.151Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-04-22T10:26:31.641Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-04-18T11:47:51.154Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"MD5加密","slug":"md5加密","date":"2020-04-23T04:00:00.000Z","updated":"2020-04-23T06:49:54.796Z","comments":true,"path":"2020/04/23/md5加密/","link":"","permalink":"/2020/04/23/md5加密/","excerpt":"","text":"#导入加密库 import hashlib #md5加密方法 def make_password(): #定义字符串 mypass = &#39;123&#39; #生成md5对象 md5 = hashlib.md5() #转码 mypass_utf8 = str(mypass).encode(encoding=&quot;utf-8&quot;) #加密操作 md5.update(mypass_utf8) #返回密文 return md5.hexdigest() print(&#39;生成的md值为：&#39;,make_password()) 输出后的结果 生成的md值为： 202cb962ac59075b964b07152d234b70","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"后端","slug":"后端","permalink":"/tags/后端/"},{"name":"django","slug":"django","permalink":"/tags/django/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"VS Code添加open with code功能，实现右键打开文件夹","slug":"vs code添加open with code功能，实现右键打开文件夹","date":"2020-04-22T16:00:00.000Z","updated":"2020-04-23T02:11:14.339Z","comments":true,"path":"2020/04/23/vs code添加open with code功能，实现右键打开文件夹/","link":"","permalink":"/2020/04/23/vs code添加open with code功能，实现右键打开文件夹/","excerpt":"","text":"首先进入VS Code的安装目录比如我的安装目录为F:\\Microsoft VS Code 在这个目录中新建一个文件，文件名随意，但后缀一定要是.reg ，比如我的为 Open File With Vs code.reg 将这个文件夹用记事本打开，或者也可以用各种编辑器，将以下内容写入，而且以下内容中的所有路径，都要改为你自己的VS Code路径 Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\*\\shell\\VSCode] @=&quot;Open with Code&quot; &quot;Icon&quot;=&quot;F:\\\\Microsoft VS Code\\\\Code.exe&quot; [HKEY_CLASSES_ROOT\\*\\shell\\VSCode\\command] @=&quot;\\&quot;F:\\\\Microsoft VS Code\\\\Code.exe\\&quot; \\&quot;%1\\&quot;&quot; Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\shell\\VSCode] @=&quot;Open with Code&quot; &quot;Icon&quot;=&quot;F:\\\\Microsoft VS Code\\\\Code.exe&quot; [HKEY_CLASSES_ROOT\\Directory\\shell\\VSCode\\command] @=&quot;\\&quot;F:\\\\Microsoft VS Code\\\\Code.exe\\&quot; \\&quot;%V\\&quot;&quot; Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\VSCode] @=&quot;Open with Code&quot; &quot;Icon&quot;=&quot;F:\\\\Microsoft VS Code\\\\Code.exe&quot; [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\VSCode\\command] @=&quot;\\&quot;F:\\\\Microsoft VS Code\\\\Code.exe\\&quot; \\&quot;%V\\&quot;&quot; 改完后记得保存并关闭，再双击这个文件将之打开，win10可能会出现类似于下图的提示 出现类似提示，点击确定就好，之后便完成了所有操作，便可以右键用VS Code打开文件夹","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Vue目录详解","slug":"Vue目录详解","date":"2020-04-21T16:00:00.000Z","updated":"2020-04-22T10:18:56.980Z","comments":true,"path":"2020/04/22/Vue目录详解/","link":"","permalink":"/2020/04/22/Vue目录详解/","excerpt":"","text":"vue-cli目录结构： 详解首先是介绍最外层文件 build 文件夹：用于存放 webpack 相关配置和脚本。开发中仅 偶尔使用 到此文件夹下 webpack.base.conf.js 用于配置 less、sass等css预编译库，或者配置一下 UI 库 config 文件夹：主要存放配置文件，用于区分开发环境、线上环境的不同。 常用到此文件夹下 config.js 配置开发环境的 端口号、是否开启热加载 或者 设置生产环境的静态资源相对路径、是否开启gzip压缩、npm run build 命令打包生成静态资源的名称和路径等 dist 文件夹：上图没有显示默认 npm run build 命令打包生成的静态资源文件，用于生产部署（我没有打包，所以上图并没有出现dist文件夹） node_modules 文件夹：存放npm命令下载的开发环境和生产环境的依赖包 src 文件夹: 存放项目源码及需要引用的资源文件 static 文件夹: 存放图片之类的静态文件 package.json：用于 node_modules资源部 和 启动、打包项目的 npm 命令管理 src目录结构 assets：存放项目中需要用到的资源文件，css、js、images等 componets文件夹：存放vue开发中一些公共组件：header.vue、footer.vue等 router文件夹：vue-router vue路由的配置文件 App.vue: App.vue就是main.js里的App,当路由文件根据路径匹配到组件时,将组件渲染到&lt;router-view/&gt;标签所在的位置，具体代码作用见下图 &lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;router-view/&gt; &lt;!--路由文件匹配的组件渲染在这里--&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;App&#39; /*其他文件引入该组件时的名称*/ } &lt;/script&gt; &lt;style&gt; #app { font-family: &#39;Avenir&#39;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } &lt;/style&gt; main.js: 主要创建Vue实例,使路由router文件和总组件App结合起来,具体代码作用见下图 import Vue from &#39;vue&#39; import App from &#39;./App.vue&#39; /*引入组件文件*/ import router from &#39;./router&#39; /*引入路由文件夹*/ Vue.config.productionTip = false; new Vue({ /*创建初始Vue实例*/ el: &#39;#app&#39;, /*组件App里的div */ router, /*路由*/ components: { App }, /*Vue实例的组件*/ template: &#39;&lt;App/&gt;&#39; /*渲染模板*/ }); src目录结构​ 因为只有一个index.js文件，我就不配图了 index.js是路由文件夹router下面的默认路由文件,具体代码作用见下图 import Vue from &#39;vue&#39; import Router from &#39;vue-router&#39; import HelloWorld from &#39;@/components/HelloWorld&#39; /*引入HelloWorld组件*/ Vue.use(Router) export default new Router({ mode : &#39;history&#39;, /*去掉访问路径的#号*/ routes: [ { path: &#39;/helloworld&#39;, /*http://localhost:8080/#/helloworld*/ name: &#39;HelloWorld&#39;, /*命名空间*/ component: HelloWorld /*HellodWorld组件,即HelloWorld.vue*/ } ] }) 简易流程文件通讯流程","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"vue","slug":"vue","permalink":"/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"hexo博客上传后自定义域名无法访问博客","slug":"hexo d 之后git pages 自定义域名失效","date":"2020-04-20T16:00:00.000Z","updated":"2020-04-21T12:42:04.252Z","comments":true,"path":"2020/04/21/hexo d 之后git pages 自定义域名失效/","link":"","permalink":"/2020/04/21/hexo d 之后git pages 自定义域名失效/","excerpt":"","text":"注：如果你没有购买域名的话，这篇文章边便看不看都无所谓了。 问题之前的博客说过，使用hexo d 之后可以将博客上传至github上，但是之后每次更新博客新建md文件，使用 hexo d 再次上传到github pages仓库，settings中的custom domain就变成空的了。 解决在 hexo 生成的博客的 source 目录下新建一个 CNAME 文件，然后在这个文件中填入自己的域名，这样就不会每次上传之后，gitpages 里的 custom domain 都被重置掉啦。 注： 文件名为 CNAME，全部大写，没有后缀。 内容只能有域名，前边不能有www. 或者 http: 等。 如何创建没有后缀的文件（只要创建文本文档的时候把后缀名也给删掉，直接写文件名就好啦。） 可以用记事本方式打开 或者 编辑器打开编辑内容。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"静态博客图片上传","slug":"静态博客图片上传","date":"2020-04-20T16:00:00.000Z","updated":"2020-04-21T02:28:35.401Z","comments":true,"path":"2020/04/21/静态博客图片上传/","link":"","permalink":"/2020/04/21/静态博客图片上传/","excerpt":"","text":"先前已经把博客搭建好了，但是写博客没有图片怎么能忍，所以来说说图片上传问题 目前我知道有两种方法 方法一、创建Images文件夹1、cd到博客等根目录下 查看_config.yml文件 查找 post_asset_folder 字段确定post_asset_folder 设置为true -&gt; post_asset_folder:true 2、当您设置 post_asset_folder 参数后，在建立文件时，Hexo 会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，这样你就可以更方便的使用资源。 3、在博客的根目录执行命令来进行插件的安装。 npm install https://github.com/CodeFalling/hexo-asset-image –save 4、然后创建一文章 hexo new &quot;test&quot; 然后查看博客的 ../source/_posts 目录下的文件，会看到存在一个test 文件夹 和 test.md 文件 5、将所需要的图片资源放到test 文件夹 内 目录结构如下： 6、书写文章使用test文件内 的图片 7、使用hexo s 命令运行本地博客如图 8、使用hexo clean hexo g hexo deploy 将本地博客推送到远程。 方法二、使用图床 简单说图床就是一个在网络上存储图片的地方，目的是为了节省本地服务器空间，加快图片打开速度，主要是个人博客和网站使用，我也就是想省一下github pages空间 这里推荐几个图床网站 SM.SM meotu z4a 聚合图床 牛图网 imgbb 详细介绍请看这里 https://www.jianshu.com/p/c35091dcba84 我以SM.SM为例 首先进入该网站,看下图。 上传成功后点击image URL，并复制下方的链接。 使用md语法插入图片，将链接粘贴到 输入图片路径中链接中，稍等片刻，图片便会加载好出现。 接着便是hexo g …. 等等正常操作了","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"vue安装及基本语法","slug":"vue安装以及简单语法","date":"2020-04-20T16:00:00.000Z","updated":"2020-04-21T13:09:22.655Z","comments":true,"path":"2020/04/21/vue安装以及简单语法/","link":"","permalink":"/2020/04/21/vue安装以及简单语法/","excerpt":"","text":"一、 node安装如果不确定自己是否安装了node,可以在命令行工具内执行： node -v （检查一下 版本）； 如果 执行结果显示： xx 不是内部命令，说明你还没有安装node , node 安装地址：http://nodejs.cn/download/ 注 ：安装 vue-cli 脚手架目前需要node版本为 v4.0 以上； 二、 vue-cli 全局安装 命令行执行 : npm install -g vue-cli // 加-g是安装到全局 安装完成以后 可以输入命令 ：vue 回车，可以看到针对vue的命令行； **: 如果npm在国内的网络环境下可能会比较慢，解决方案： 使用淘宝镜像: 官方网址：http://npm.taobao.org； 安装：npm install cnpm -g –registry=https://registry.npm.taobao.org； 注意：安装完后最好查看其版本号cnpm -v或关闭命令提示符重新打开，安装完直接使用有可能会出现错误 注：cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm（以下操作将以cnpm代替npm） 如何更新npm的方法： 可以使用 npm install -g npm 来更新版本 三、初始化项目命令为 vue init webpack 项目名 项目名称随意，我这里想把名称写为demo，所以命令为 vue init webpack demo 执行之后将会 自动初始化一个文件夹 ：demo 手动打开demo文件夹 可以看到 已经初始化好了 一个基本的项目： 四、启动项目继续执行： cd demo (这是进入到demo文件夹的命令) 然后执行 安装 ：npm install 注： npm install 执行可以进行vue已经vue的插件安装，在第三步的时候，已经初始化了项目，并且在 package.json 里面已经有相关配置，所以在这里可以直接安装； 安装完成之后再执行命令： npm run dev 然后可以看到 然后将 后边的的 http://localhost:8080/ 复制粘贴到浏览器地址栏 整个项目就已经启动了： 五、项目文件配置介绍build 和 config 是关于webpack的配置，里面包括一些server,和端口； node_modules: 安装依赖代码库； src : 存放源码； static：存放第三方静态资源的，static里面的.gitkeep，如果为空，也可以提交到gitHub上面，正常情况下，是不可以提交的。 入口文件： index.html 和 main.js Vue基础语法 V-model 数据双向绑定 单向：数据变 -&gt; 页面变 V-bind：属性绑定 V-on：事件绑定 V-clock：避免差值表达式所带来的闪烁问题 V-HTML：会将绑定的内容转义输出为HTML，&lt;h1&gt;&lt;/h1&gt; V-Text：不会转义输出 V-if：不保留不存在的条件语句 V-show：保留存在的，只是样式设置为了display:none V-for：v in xxx","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Github Pages + Hexo搭建静态博客","slug":"Github Pages + Hexo搭建静态博客","date":"2020-04-19T16:00:00.000Z","updated":"2020-04-21T02:28:56.657Z","comments":true,"path":"2020/04/20/Github Pages + Hexo搭建静态博客/","link":"","permalink":"/2020/04/20/Github Pages + Hexo搭建静态博客/","excerpt":"","text":"写给想要拥有一个自己的网站但没有资金成本的小白与曾经的自己。 前言以下的链接除了github仓库，其他都不是我本人的 ，是制作博客主题的作者的链接，请不要混淆。 虽说是网站，对于个人来说，或许一般叫作博客。但我不希望它仅仅是一个博客，而是能够成为一个处于自己现实生活之外、自由、实验、不用畏惧他人眼光甚至可以独断专行的地方。 已经有所基础的同学大可跳读或者直接关闭。 关键词 Hexo 静态博客 无服务器 GitHub Pages hexo-theme-yun 步骤安装 Node.js 什么是 Node.js ？ 这得从什么是 JS 说起，JS 也就是 JavaScript。（为什么有种从盘古开天辟地开始的感觉）没错，JavaScript 就是网页的盘古。JavaScript 是一种编程语言，我们所见到的网页中的交互和逻辑处理几乎都是由 JavaScript 完成。JavaScript 语法简单，易学易用。（当然也请不要小瞧它，虽然它入门门槛低，但上限同样也很高。包括但不限于实现网站前后端，手机桌面应用程序，机器学习，计算机图形学等。）在 Node.js 诞生前，JavaScript 都运行于浏览器端。也就是说，它是鱼，浏览器是装满了水的水缸。2008 年，Chrome V8 诞生。2009 年，Node.js 诞生。并成为 GitHub 早期最著名的开源项目。GitHub 可能大家已有所了解，后续再说。Node.js 便是一个基于 Chrome V8 引擎的 JavaScript 运行环境。（当年第一次看到这句话时，我也一脸懵逼。）按照我的理解，JavaScript 是鱼，Chrome V8 就是抽水机，Node.js 则把这台抽水机也装在你电脑上。于是你的电脑也有了 Node.js 这个和浏览器相似的水缸，也可以在里面运行 JavaScript 了！当然 Node.js 和浏览器端还是因为自身定位和一些历史原因而有些许区别的，不再展开。 建议下载长期支持版而非当前发布版（因为如果是最新版，容易出现一些奇妙的 bug）。 全部默认下一步进行安装。 Windows 打开命令提示符。Linux 用户右上角关闭本标签页。 后续如提到输入命令，均默认指打开终端进行输入。 输入 node --version，如果得到的版本号与你方才安装的一致，那么 Node.js 就已经成功安装。 Git 与 GitHub安装 Git Git 是一个开源的分布式版本控制系统，由 Linus Torvalds（同时也是 Linux 的作者）为了管理 Linux 开发而开发。简而言之，是一个版本管理工具。譬如设计师设计好了第三版的海报，客户却说还是要第一版吧，这时便可以通过 Git 快速回退到最初的版本。你只需要把每次更改的状态（Git 会自动进行检测，你只要掌握基础的几条命令就可以了）告诉 Git，而不需要每个版本都保存一份压缩包，既方便也能大大节约空间。（当然这主要只对代码文本起作用，因为 Git 的本质是记录各行代码的增减，倘若是像视频、海报这类二进制文件来说便体现不出丝毫优势了。当然想要应对这种场景还有 Git LFS。） 注册 GitHub GitHub 一听便与 Git 有所渊源。Git 在英文中是懒人、饭桶之意。Hub 则是中心、集线器的意思。譬如 USB 集线器就是 USB Hub。所以 GitHub 就是饭桶中心（大雾）。GitHub 是全世界最大的开源项目与代码托管平台，也是众多开发者的交流场所。还是全球最大的同性交友网站。而代码托管本身用到的正是上文提到的 Git 技术。 注册 GitHub 账号。（虽然都是英文，但不必畏惧，也并不会造成使用障碍，只要记得最常用的选项含义即可，以及善用手头的翻译软件。谷歌浏览器的话在页面右击鼠标便有 【翻译成中文】的选项） 注意：注册时的英文用户名将成为你可以使用的免费域名前缀。 登录 GitHub。 为什么要用 GitHub？对于平民玩家来说，在初次尝试建立自己的网站时，也许并不会有闲钱或者说决心来购买自己的服务器与域名。而 GitHub 则提供了 GitHub Pages 这一服务。用户们可以利用这一服务，部署自己的静态站点。 点击右上角的 + -&gt; New repository 新建仓库。 我这里因为已经有同名仓库，所以提示了重复。 仓库名称务必为 你的用户名.github.io，用户名是英文，大小写无所谓，但建议统一小写。（因为你会发现时常切换大小写很麻烦） 为什么必须这个作为仓库名？GitHub Pages 服务的命名规范，同时它也将成为你的专属域名。当然，你也可以购置自己的专属域名并用它来提供内容。 点击 Create repository。 安装HexoHexo GitHub: http://github.com/hexojs/hexo 官方文档（直接参考文档也是一个不错的选择） 为嘛使用 Hexo ？Hexo 是一个快速、简洁而强大的博客框架，基于 Node.js，同样托管于 GitHub 之上。生态中拥有众多插件主题。你可以基于它快速生成一些静态页面。你可以使用别人的各种主题与插件，也可以自己定制开发想要的功能。为什么不是…?其他常用的博客框架还有 WordPress，Typecho，Ghost 等，但这些往往都需要购置自己的服务器，而无法静态化地部署到 GitHub Pages 上。（当然，相应的功能和灵活性也大大提升。）静态化站点还有一个优势就是访问速度往往更快。静态网站生成器还有 Vuepress，Gatsby 等。但这些多是为了写文档而量身定制的，你也可以使用它们，但是相较 Hexo 的博客定位，它们关于博客的插件和主题以及解决办法会少得多。Hexo 提供的功能与 Hugo 几乎都有，（生成大量文件时，甚至比 Hexo 更快）不过它是基于 GO 语言。日后你想对自己的网站进行自定义，即便是 Hugo，你编写前端的交互仍旧需要使用 JavaScript，所以选择基于 JavaScript 的 Hexo 可以降低学习成本。（其实是我找不到好看的hugo主题） 在终端中输入以下命令： npm install hexo-cli -g # 如果安装失败，可能是没有权限，可以尝试头部加上 sudo 重新执行 # sudo npm install hexo-cli -g npm 是随 Node.js 一起被安装的包管理工具，你可以理解成 Node.js 自带的应用商店。install 自然是安装。hexo-cli 则是 hexo 的终端工具，可以帮助你生成一些模版文件，之后再用到。-g 代表的是全局安装。也就是在任何地方都可以使用，否则会只能在安装的目录下使用。 此时，请先通过 cd 进入你本地电脑打算存储网站代码的文件夹目录。（或者右键文件夹 Git Bash Here） cd | DOS 命令cd （LINUXSHELL 命令） 譬如： 注意：这里是你自定义的目录，请不要复制粘贴 # &#39;#&#39; 字符后的文字代表注释，不需要输入 # Windows cd C:\\Users\\YunYou\\Documents\\GitHub\\ # macOS # cd /Users/yunyou/github/ 接下来输入： hexo init 你的名字.github.io hexo 正是因为我们之前安装了 hexo-cli 这一个包，所以我们可以在终端中使用 hexo 这一命令。init 初始化博客的模版文件。后面跟的是你要新建的文件夹，最好和你此前新建的仓库名一致。 # 进入你的博客文件夹 cd 你的名字.github.io # 默认安装所有 `package.json` 文件中提到的包 npm install # 你也可以缩写成 hexo s hexo server server 代表开启本地的 Hexo 服务器，这时你就可以打开浏览器，在地址栏中输入 localhost:4000 就可以看到本地的网页了。 按 Ctrl + C 终端服务器的运行。 至此，基础的模版页面便已经搭建好了。 使用 Hexo 主题Hexo 默认提供的是 hexo-theme-landscape 主题。默认主题样式简单，功能较少。所以大多数人并不会使用默认主题。 这里是别人开发的主题 我只是下载用用 hexo-theme-yun。 如果有人看这篇文章的话，麻烦点击 请去github收藏一下作者的主题 下载 Hexo 主题进入终端（确保路径处于你此前使用 Hexo 初始化好的文件夹目录下，即 xxx.github.io，后简称为 Hexo 目录），输入以下命令。 实际上你也可以直接在 VS Code 中使用终端。 git clone https://github.com/YunYouJun/hexo-theme-yun themes/yun 这里便使用到了我们此前安装的 Git，git clone 即代表克隆（也就是复制的作用）本主题（托管于 GitHub，链接便是主题所在的地址），themes/yun 则代表放在你 Hexo 文件夹下的 themes/yun 文件夹里（没有该文件夹会自动新建）。 编辑 Hexo 配置在你此前通过 Hexo 初始化生成的文件目录下，会存在一个 _config.yml 文件。 yml 是 YAML 文件的后缀名，YAML 是 “YAML Ain’t a Markup Language”（YAML 不是一种标记语言） 的缩写，但它实际上还是一种标记语言。你可以将其理解为存储数据的一种文本格式，这也是其诞生的目的。 如果你听说过 JSON，那你就更能明白它是干什么的了。 它是 Hexo 的配置文件，关于各配置选项的意义你可以查看 配置 | Hexo。 在 _config.yml 中找到 theme 这个字段，将其后的 landscape 修改为 yun。 theme: yun pug 是一种模板引擎，可以渲染为 HTML 字符串。类似的还有 ejs，swig 等，语法和设计理念有所不同。stylus 是一种 CSS 预处理器，可以渲染为 CSS。类似的还有 scss，less，同样只是语法和设计理念有所差异。 由于主题使用了 pug 和 stylus，而 Hexo 自带的一般是 ejs 与 stylus，所以你可能还需要输入以下命令安装渲染器。 npm install hexo-render-pug hexo-renderer-stylus 这时再像此前那般使用 hexo server 重新启动服务器，你就可以看到一个不一样的主题风格的页面了。 自定义主题配置当启动时，会使用主题的默认配置。但这不一定是你想要的。所以你可以对主题进行一些自定义。 主题的配置文件放在 themes/yun/_config.yml 文件中。且慢，你最好不要直接修改主题的默认配置。倘若日后主题升级更新了怎么办吗，难道还要重新配置一遍吗？ 最好的解决方案就是在博客根目录下（不是主题目录）新建 source/_data/yun.yml。（若 source/_data 目录不存在，请新建） 本主题将自定义配置与默认配置进行合并，因此你只需要在 yun.yml 文件中自定义你需要的配置即可，其余仍将自动采用默认配置。 譬如我们需要更换头像。在 yun.yml 中填写。 你可以在 source 文件夹下新建 images 文件夹，用来存储你的图片。也可以使用 SM.MS 等图床工具上传你的图片文件，获取在线链接。 avatar: url: /images/avatar.jpg # 你的头像图片地址 rounded: true opacity: 1 更换主题色彩，比如换成黑色，黑色的十六进制颜色代码是 #000000。 colors: primary: &quot;#000000&quot; 这时你的主题色调就会变为黑色。 这只是一个配置项的简单示例，更多配置你可以参考我的主题文档或直接在 theme/yun/_config.yml 中查看，并根据自己的需要进行配置。 生成静态文件至今我们的工作都是在本地进行，想必你也很想放到线上与小伙伴们分享。这便轮到了 GitHub Pages 的出场，不过 GitHub Pages 只支持纯静态文件。 所以我们需要使用以下命令先来生成站点的静态文件。 # 如果进行多次生成，为了避免受错误缓存影响，最好使用 hexo clean 先清除一遍。 hexo generate # 缩写为 hexo g 此时你的文件夹目录下会出现 public 这个文件夹，里面存放的就是你站点的静态文件。 与远程仓库建立关联接下来我们将本地的仓库与此前在 GitHub 上建立的仓库建立关联。 git init # 初始化 Git 仓库，只需要执行一次即可 在将其部署到 GitHub Pages 上之前，我们最好先建立一个分支。 什么是分支？Git 提供了版本管理功能，其中还有一个分支功能，你现在可以简单地将其理解为平行世界。 你的名字.github.io 部署后，GitHub Pages 将默认使用你的 master 分支作为静态文件部署。所以我们最好新建一个 hexo 分支（命名无所谓）用来存储 Hexo 地源代码，master 分支则用来存储部署后的静态文件。 git checkout -b hexo 这时便成功建立了一个 hexo 分支。（此后的工作都将在 hexo 分支下进行） 你可以通过 git branch -v 来查看当前有哪些分支，使用 git branch 分支名 来切换到对应的分支。 Git 学习笔记 部署为了更方便的部署到 GitHub Pages，Hexo 提供了 hexo-deployer-git 插件。 老规矩，安装。 npm install hexo-deployer-git 在 _config.yml 中配置。 deploy: type: git repo: 你此前新建的仓库的链接 # 比如：https://github.com/zl956973503/zl956973503.github.io branch: master # 默认使用 master 分支 message: Update Hexo Static Content # 你可以自定义此次部署更新的说明 保存，部署！ 第一次可能需要你输入用户名与密码。密码输入的时候不会出现 ***，不要害怕，已经输入进去了。 hexo deploy 等待完成后，打开网址 https://你的名字.github.io 就能看到你的线上网站了。 使用 https，http 可能无法正常打开。HTTPS 是多了安全加密的 HTTP，Chrome 浏览器已经默认会显示 http 链接为不安全。为了安全，建议开启强制 https 跳转。项目地址页面 -&gt; Settings -&gt; Options -&gt; GitHub Pages -&gt; Enforce HTTPS。（翻到下面）此时，http 网址会自动重定向到 https 备份与自动部署我们当前只是将生成的静态文件部署到了云端。 为了以防万一，我们应该将网站的源代码文件也推送到 GitHub 仓库备份。 # 与远程 Git 仓库建立连接，只此一次即可 git remote add origin https://github.com/你的用户名/你的名字.github.io 接下来准备提交，这几句命令将是你以后每次备份所需要输入。 # 添加到缓存区 git add -A git commit -m &quot;这次做了什么更改，简单描述下即可&quot; # 推送至远程仓库 git push # 第一次提交，你可能需设置一下默认提交分支 # git push --set-upstream origin hexo 每次推送都要输入这三条命令，你可能觉得有些麻烦。那么你可以编写 bash 脚本。 譬如，在根目录下新建 update.sh。 # 如果没有消息后缀，默认提交信息为 `:pencil: update content` info=$1 if [&quot;$info&quot; = &quot;&quot;]; then info=&quot;:pencil: update content&quot; fi git add -A git commit -m &quot;$info&quot; git push origin hexo 此后更新的话，只需要在终端执行 sh update.sh 即可。 更新麻烦，每次部署也很麻烦，可以使用持续集成进行自动部署。 什么是持续集成？持续集成是一种软件开发实践。对软件进行自动化构建，以此来发现错误。Travis CI 就是一个线上持续集成服务的提供商。它可以拉取你每次推送到 GitHub 上的代码，然后根据你的要求对其进行构建。我们可以趁机让它自动生成网站静态文件，然后自动帮我们部署。除此之外，你还可以使用 GitHub Actions ，Netlify 等服务。GitHub Actions 相比 Travis 等，自身便拥有仓库的 Token，不再需要额外设置，可以直接使用 secrets.GITHUB_TOKEN。推荐一个专门用来部署 gh-pages 的 Actions actions-gh-pages 关于更多更具体的自动化部署方案和操作步骤，可以参考 ChrAlpha 的 初探无后端静态博客自动化部署方案。 他在文章中详细介绍了 Netlify 、GitHub Actions 和 Travis CI 的部署方法。 你也可以参考 Hexo 的官方文档 将 Hexo 部署到 GitHub Pages 我就不在此画蛇添足。 至此，你的站点便基本搭建完成，此后继续对主题进行自定义吧。 Yun 主题文档 开始写作文章输入以下命令即可新建 xxx.md 文件。 hexo new post xxx md 是 Markdown 的后缀名，是一种简洁方便的文本标记语言。你只需要记住简单的几种语法，就可以快速进行编写。为什么使用 Markdown？首先 Hexo 本身就是将 Markdown 转化为静态的 Html 文件，来方便用户编写文章。Markdown 就好似介于 Word 与 TXT 文本之间。Word 体积大、大部分功能实际上根本用不到，且最后的文档常常带有许多冗余信息。而 TXT 却无法实现加粗、标题、下划线、水平分割线等常用的功能。（这里所说的 TXT 只是一种纯文本格式的代称，实际上 Markdown 也是纯文本文件，不过通过语法和 Markdown 编译器，我们就可以看到一些简单的样式。） 譬如本文就是通过 Markdown 编写。 # 一级标题 ## 二级标题 **加粗文字** 更多语法（虽然说是更多，但是其实也没多少）：Markdown 基本语法 页面你可以新建一些自己的自定义页面。 譬如直接在 Hexo 目录下的 source 文件夹下直接新建 HTML 进行编写。 也可以通过以下命令来新建页面。（当然还是 Markdown，不过也是可以在 Markdown 里写 HTML 的，也会被渲染出来。） hexo new page xxx 说到这里，就不得不提一提本主题的特色功能了。 生成你的老婆列表页面。按一定格式书写即可。见文档。 FAQ如何绑定你的自定义域名？首先，你得有个自己的域名。 可以去 阿里云 购买服务器 并使用 CNAME 解析到 你的名字.github.io。（当然 A 记录直接解析到 GitHub Pages IP 地址也可以。） Managing a custom domain for your GitHub Pages site 在 Hexo 工作目录下 source 文件夹下新建 CNAME 文件（没有后缀名）。 CNAME 即相当于告诉 GitHub 允许将 xxx.github.io 为你的域名提供服务。source 目录下的文件除了特殊的 markdown 会被解析为 html，其余都会原样复制到生成的静态文件夹中。所以你需要在 source 文件夹下建有 CNAME，它会在生成静态文件时，将 CNAME 拷贝到静态文件夹并部署到 master 分支。如果只是在 GitHub 上设置（项目地址页面 -&gt; Settings -&gt; Options -&gt; GitHub Pages -&gt; Custom domain），它会自动添加到 master 分支上，但随后不包含 CNAME 的部署会将其覆盖。 内容填写你的域名即可。 About custom domains and GitHub Pages 结语个人网站同样可以用来做许多事情，你可以将其用来记录生活、回忆、创作、学习笔记、开发经验等（包括作为一个试验平台）。可以与熟悉的人分享，也可以作为另一个世界另一个自己的展示。 多年后，回看起自己当初写下的内容，未尝不是件有趣的事情。 善始者众，善终者寡。 臣闻善作者，不必善成；善始者，不必善终。「史记·乐毅列传」 希望大家能有毅力坚持下去，不忘初心。 永远相信美好的事情即将发生","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"进程和线程的简单理解","slug":"进程和线程的简单理解","date":"2020-04-08T16:00:00.000Z","updated":"2020-04-21T02:28:29.744Z","comments":true,"path":"2020/04/09/进程和线程的简单理解/","link":"","permalink":"/2020/04/09/进程和线程的简单理解/","excerpt":"","text":"抽象类比：单CPU：一台单核处理器计算机 = 一个车间；多CPU：一台多核处理器计算机 = 一座工厂；进程：一个车间 = 一个进程； （即一个运行的程序）多进程：一座工厂可以同时运行多个车间；CPU和进程：单CPU只能同时运行单个进程，多CPU可以同时运行多个进程。线程：车间内一个工人 = 一个线程；进程与线程：一个进程可以包括多个线程。线程间内存共享：车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。内存安全：可是，每个车间容纳大小不同，有的最多只能容纳一个人。车间人满的时候，其他人就进不去了。一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。互斥锁：一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫”互斥锁”–Mutex，防止两个线程同时读写某一块内存区域。信号量：这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。锁和信号量：不难看出，互斥锁是信号量的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。操作系统的资源分配与调度逻辑 以多进程形式，允许多个任务同时运行； 以多线程形式，允许单个任务分成不同的部分运行； 提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。","categories":[{"name":"python","slug":"python","permalink":"/categories/python/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"python","slug":"python","permalink":"/categories/python/"}]},{"title":"Mysql中的锁","slug":"MySql中的锁","date":"2020-04-03T16:00:00.000Z","updated":"2020-04-21T02:29:14.972Z","comments":true,"path":"2020/04/04/MySql中的锁/","link":"","permalink":"/2020/04/04/MySql中的锁/","excerpt":"","text":"锁分类 按操作划分：DML锁，DDL锁 按锁的粒度划分：表级锁、行级锁、页级锁 按锁级别划分：共享锁、排他锁 按加锁方式划分：自动锁、显示锁 按使用方式划分：乐观锁、悲观锁 乐观锁实现方法 每次获取商品时，不对该商品加锁。 在更新数据的时候需要比较程序中的库存量与数据库中的库存量是否相等，如果相等则进行更新 反之程序重新获取库存量，再次进行比较，直到两个库存量的数值相等才进行数据更新。 #### 乐观锁实现加一操作代码 # 我们可以看到，只有当对数量-1操作时才会加锁，只有当程序中值和数据库中的值相等时才正真执行。 &#39;&#39;&#39; //不加锁 select id,name,stock where id=1; //业务处理 begin; update shop set stock=stock-1 where id=1 and stock=stock; commit; &#39;&#39;&#39; 悲观锁 每次获取商品时，对该商品加排他锁。 也就是在用户A获取获取 id=1 的商品信息时对该行记录加锁，期间其他用户阻塞等待访问该记录。 #### 悲观锁实现加一操作代码 # 我们可以看到，首先通过begin开启一个事物，在获得shop信息和修改数据的整个过程中都对数据加锁，保证了数据的一致性。 &#39;&#39;&#39; begin; select id,name,stock as old_stock from shop where id=1 for update; update shop set stock=stock-1 where id=1 and stock=old_stock; commit &#39;&#39;&#39; 排它锁 排它锁又叫写锁，如果事务T对A加上排它锁，则其它事务都不能对A加任何类型的锁。获准排它锁的事务既能读数据，又能写数据。 用法 ： SELECT … FOR UPDATE 共享锁(share lock) 共享锁又叫读锁，如果事务T对A加上共享锁，则其它事务只能对A再加共享锁，不能加其它锁。 获准共享锁的事务只能读数据，不能写数据。 用法： SELECT … LOCK IN SHARE MODE;","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"ORM操作","slug":"ORM操作","date":"2020-04-02T16:00:00.000Z","updated":"2020-04-21T02:29:20.424Z","comments":true,"path":"2020/04/03/ORM操作/","link":"","permalink":"/2020/04/03/ORM操作/","excerpt":"","text":"Django模型之ORM操作ORM介绍 什么是ORMORM 全拼Object-Relation Mapping. 中文意为 对象-关系映射. 在MVC/MVT设计模式中的Model模块中都包括ORM ORM优势 只需要面向对象编程, 不需要面向数据库编写代码. 对数据库的操作都转化成对类属性和方法的操作.不用编写各种数据库的sql语句. 实现了数据模型与数据库的解耦, 屏蔽了不同数据库操作上的差异. 不在关注用的是mysql、oracle…等.通过简单的配置就可以轻松更换数据库, 而不需要修改代码. ORM劣势相比较直接使用SQL语句操作数据库,有性能损失.根据对象的操作转换成SQL语句,根据查询的结果转化成对象, 在映射过程中有性能损失. ORM和数据库关系：在Django中model是你数据的单一、明确的信息来源。它包含了你存储的数据的重要字段和行为。通常，一个模型（model）映射到一个数据库表. 基本情况： 每个模型都是一个Python类，它是django.db.models.Model的子类。 模型的每个属性都代表一个数据库字段。 ORM操作增加操作 # 通过python manage.py shell 进入到shell下 # 进入shell环境以后，首先导入模型 from polls.models import * # 导入全部模型 from django.utils import timezone # 导入时间模块 # 创建方法一： q = Question(question_text=&quot;什么地方的菜最有特色？&quot;, pub_date=timezone.now()) q.save() # 关联创建，用问题关联创建选项 q.choice_set.create(choice_text=&quot;湖南&quot;) # 创建方法二： q = Question() # 创建实例对象 q.question_text = &quot;什么地方的菜最有特色？&quot; q.pub_date = timeaone.now() q.save() # 创建方法三： Question.objects.create(question_text=&quot;什么地方的菜最有特色？&quot;, pub_date=timezone.now()) # 批量创建，可以提高性能，减少对数据库的访问写入次数 bulk_create() # 批量添加，需要传入的参数是一个列表 Question.objects.bulk_create( [ Question(question_text=&quot;什么地方的菜最有特色？&quot;, pub_date=timezone.now()), Question(question_text=&quot;什么地方的景色最美？&quot;, pub_date=timezone.now())， ] ) 修改操作# 修改方法1： Question.objects.update(question_text = &quot;什么地方最好玩？&quot;) # 修改方法2： q = Question.objects.update(pk=1) q.question = &quot;什么地方最好玩？&quot; q.save() 删除操作# 删除：(先查询到某个queryset对象，然后用删除命令) q = Question.objects.get(id=1) q.delete() 查询操作必会的方法 # 1、 all(): 查询所有结果 question_list = Question.objects.all() # 返回一个queryset集合 # 2、 filter(**kwargs): 它包含了与所给筛选条件相匹配的对象 question_list = Question.objects.filter(pk=1) # 返回一个queryset集合,如果没有查询到，返回一个空集合,不会报错 # 3、 get(**kwargs): 返回与所给筛选条件相匹配的对象，返回结果有且只有一个，如果符合筛选条件的 对象超过一个或者没有都会抛出错误。 question = Question.objects.get(pk=1) # 返回一个queryset对象，并且只会得到一个数据，如果没有查询到，会报DoesNotExist的错误 # 4、 exclude(**kwargs): 它包含了与所给筛选条件不匹配的对象 question = Question.objects.exclude(id__in=[11, 22, 33]) # 筛选id除了11，22，33外的，其它的数据 # 5、 values(*field): 返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系列 model的实例化对象，而是一个可迭代的字典序列 question = Question.objects.values() # 返回结果：[{&quot;id&quot;: 1, &quot;question_name&quot;: &quot;xxxxxxx&quot;}, {&quot;id&quot;: 2, &quot;question_name&quot;: &quot;xxxxxxx&quot;}, ...] # 6、 values_list(*field): 它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序 列 question = Question.objects.values_list() # 返回结果：[(1, &quot;xxxxxxx&quot;), (2, &quot;xxxxxxx&quot;), ....] # 7、 order_by(*field): 对查询结果排序 user_list = User.objects.order_by(&quot;-id&quot;) # “-” 按id降序排列 user_list = User.objects.order_by() # 按id升序排列（默认） # 8、 reverse(): 对查询结果反向排序，请注意reverse()通常只能在具有已定义顺序的QuerySet 上调用(在model类的Meta中指定ordering或调用order_by()方法)。 user = User.objects.all().reverse() # 把查询的结果进行反转 # 9、 distinct(): 从返回结果中剔除重复纪录(如果你查询跨越多个表，可能在计算QuerySet时得到 重复的结果。此时可以使用distinct()，注意只有在PostgreSQL中支持按字段 去重。) Question.objects.all().distinct() # 把结果中重复的记录剔除 # 10、 count(): 返回数据库中匹配查询(QuerySet)的对象数量。 user_count = User.objects.count() # 返回user表中的用户数量 # 11、 first(): 返回第一条记录 User.objects.first() # 12、 last(): 返回最后一条记录 User.objects.last() # 13、 exists(): 如果QuerySet包含数据，就返回True，否则返回False user = User.objects.filter(pk=1).exists() # 返回True 或者False if user: print(&quot;OK&quot;) 查询条件在 ORM 层面，这些查询条件都是使用 field + __ + condition 的方式来使用 # 精确的 等于,如果提供一个None,SQL解析为Null article = Article.objects.get(id__exact=14) article = Article.objects.get(id__exact=None) &#39;&#39;&#39; 对应sql select ... from article where id=14; select ... from article where id IS NULL; &#39;&#39;&#39; # iexact 使用like查询 article = Article.objects.filter(title__iexact=&#39;hello world&#39;) &#39;&#39;&#39; 等价于 select ... from article where title like &#39;hello world&#39; &#39;&#39;&#39; # 包含:contains,区分大小写 articles = Article.objects.filter(title__contains=&#39;hello&#39;) &#39;&#39;&#39; 等价于select ... where title like binary &#39;%hello%&#39;; &#39;&#39;&#39; # icontains 忽略大小写 articles = Article.objects.filter(title__icontains=&#39;hello&#39;) &#39;&#39;&#39; 等价于 select ... where title like &#39;%hello%&#39;; &#39;&#39;&#39; # in 提取那些给定的field的值是否在给定的容器中。容器可以为list、tuple或者任何一个可以迭代的对 象，# 包括QuerySet对象 articles = Article.objects.filter(id__in=[1,2,3]) &#39;&#39;&#39; 等价于 select ... where id in (1,3,4) &#39;&#39;&#39; # 当然也可以传递一个QuerySet对象进去。示例代码如下： inner_qs = Article.objects.filter(title__contains=&#39;hello&#39;) categories = Category.objects.filter(article__in=inner_qs) &#39;&#39;&#39; 等价于:以上代码的意思是获取那些文章标题包含hello的所有分类。 select ...from category where article.id in (select id from article where title like &#39;%hello%&#39;); &#39;&#39;&#39; # gt 大于 articles = Article.objects.filter(id__gt=4) &#39;&#39;&#39; 等价于 select ... where id &gt; 4; &#39;&#39;&#39; # gte 大于等于 # lt 小于 # lte 小于等于 # startswidth 开始,大小写敏感 articles = Article.objects.filter(title__startswith=&#39;hello&#39;) &#39;&#39;&#39; 等价于: select ... where title like &#39;hello%&#39; &#39;&#39;&#39; # istartswidth 大小写不敏感 # endswidth 以**结尾,大小写敏感 articles = Article.objects.filter(title__endswith=&#39;world&#39;) &#39;&#39;&#39; 等价于:select ... where title like &#39;%world&#39;; &#39;&#39;&#39; # iendswidht 以**结尾,忽略大小写 # range 判断某个field的值是否在给定的区间中, 两个范围之间 from django.utils.timezone import make_aware from datetime import datetime start_date = make_aware(datetime(year=2018,month=1,day=1)) end_date = make_aware(datetime(year=2018,month=3,day=29,hour=16)) articles = Article.objects.filter(pub_date__range=(start_date,end_date)) # isnull articles = Article.objects.filter(pub_date__isnull=False) # regex和iregex： 正则 articles = Article.objects.filter(title__regex=r&#39;^hello&#39;) &#39;&#39;&#39; 等价:select ... where title regexp binary &#39;^hello&#39;; &#39;&#39;&#39; &#39;&#39;&#39; 以上代码的意思是提取所有发布时间在2018/1/1到2018/12/12之间的文章。 将翻译成以下的SQL语句： select ... from article where pub_time between &#39;2018-01-01&#39; and &#39;2018-12-12&#39;。 需要注意的是，以上提取数据，不会包含最后一个值。也就是不会包含2018/12/12的文章。 而且另外一个重点，因为我们在settings.py中指定了USE_TZ=True，并且设置了 TIME_ZONE=&#39;Asia/Shanghai&#39;，因此我们在提取数据的时候要使用django.utils.timezone.make_aware 先将datetime.datetime从navie时间转换为aware时间。make_aware会将指定的时间转换为TIME_ZONE中 指定的时区的时间。 &#39;&#39;&#39; 根据关联的表查假如现在有两个 ORM 模型，一个是 Article ，一个是 Category 。代码如下： class Category(models.Model): &quot;&quot;&quot;文章分类表&quot;&quot;&quot; name = models.CharField(max_length=100) class Article(models.Model): &quot;&quot;&quot;文章表&quot;&quot;&quot; title = models.CharField(max_length=100,null=True) category = models.ForeignKey(&quot;Category&quot;,on_delete=models.CASCADE) 比如想要获取文章标题中包含”hello”的所有的分类。那么可以通过以下代码来实现： categories = Category.object.filter(article__title__contains(&quot;hello&quot;)) 聚合函数聚合函数是通过 aggregate 方法来实现的。 Avg ：求平均值。比如想要获取所有图书的价格平均值。那么可以使用以下代码实现 from django.db.models import Avg result = Book.objects.aggregate(Avg(&#39;price&#39;)) print(result) 以上的打印结果是： {&quot;price__avg&quot;:23.0} 其中 price__avg 的结构是根据 field__avg 规则构成的。如果想要修改默认的名字，那么可以将 Avg 赋值给一个关键字参数。示例代码如下： from django.db.models import Avg result = Book.objects.aggregate(my_avg=Avg(&#39;price&#39;)) print(result) 那么以上的结果打印为： {&quot;my_avg&quot;:23} Count ：获取指定的对象的个数。示例代码如下： from django.db.models import Count result = Book.objects.aggregate(book_num=Count(&#39;id&#39;)) 以上的 result 将返回 Book 表中总共有多少本图书。 Count 类中，还有另外一个参数叫做 distinct ，默认是等于 False ，如果是等于 True ，那么将去掉那些重复的值。比如要获取作者表中所有的不重复的邮箱总共有多少个，那么可以通过以下代码来实现： from djang.db.models import Count result = Author.objects.aggregate(count=Count(&#39;email&#39;,distinct=True)) Max 和 Min ：获取指定对象的最大值和最小值。比如想要获取 Author 表中，最大的年龄和最小的年龄分别是多少。那么可以通过以下代码来实现： from django.db.models import Max,Min result = Author.objects.aggregate(Max(&#39;age&#39;),Min(&#39;age&#39;)) 如果最大的年龄是88,最小的年龄是18。那么以上的result将为： {&quot;age__max&quot;:88,&quot;age__min&quot;:18} Sum ：求指定对象的总和。比如要求图书的销售总额。那么可以使用以下代码实现： from djang.db.models import Sum result = Book.objects.annotate(total=Sum(&quot;bookstore__price&quot;)).values(&quot;name&quot;,&quot;total&quot;) 以上的代码 annotate 的意思是给 Book 表在查询的时候添加一个字段叫做 total ，这个字段的数据来源是从 BookStore 模型的 price 的总和而来。 values 方法是只提取 name 和 total 两个字段的值。 更多的聚合函数请参考官方文档：https://docs.djangoproject.com/en/2.0/ref/models/querysets/#aggregation-functions aggregate和annotate的区别： aggregate ：返回使用聚合函数后的字段和值。 annotate ：在原来模型字段的基础之上添加一个使用了聚合函数的字段，并且在使用聚合函数的时候，会使用当前这个模型的主键进行分组（group by）。 比如以上 Sum 的例子，如果使用的是 annotate ，那么将在每条图书的数据上都添加一个字段叫做 total ，计算这本书的销售总额。 而如果使用的是 aggregate ，那么将求所有图书的销售总额。 from django.db import models class Author(models.Model): &quot;&quot;&quot;作者模型&quot;&quot;&quot; name = models.CharField(max_length=100) age = models.IntegerField() email = models.EmailField() class Meta: db_table = &#39;author&#39; class Publisher(models.Model): &quot;&quot;&quot;出版社模型&quot;&quot;&quot; name = models.CharField(max_length=300) class Meta: db_table = &#39;publisher&#39; class Book(models.Model): &quot;&quot;&quot;图书模型&quot;&quot;&quot; name = models.CharField(max_length=300) pages = models.IntegerField() price = models.FloatField() rating = models.FloatField() author = models.ForeignKey(Author,on_delete=models.CASCADE) publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE) class Meta: db_table = &#39;book&#39; class BookOrder(models.Model): &quot;&quot;&quot;图书订单模型&quot;&quot;&quot; book = models.ForeignKey(&quot;Book&quot;,on_delete=models.CASCADE) price = models.FloatField() class Meta: db_table = &#39;book_order&#39; F表达式和Q表达式：F表达式：F表达式 是用来优化 ORM 操作数据库的。比如我们要将公司所有员工的薪水都增加1000元，如果按照正常的流程，应该是先从数据库中提取所有的员工工资到Python内存中，然后使用Python代码在员工工资的基础之上增加1000元，最后再保存到数据库中。这里面涉及的流程就是，首先从数据库中提取数据到Python内存中，然后在Python内存中做完运算，之后再保存到数据库中。示例代码如下： employees = Employee.objects.all() for employee in employees: employee.salary += 1000 employee.save() 而我们的 F表达式 就可以优化这个流程，他可以不需要先把数据从数据库中提取出来，计算完成后再保存回去，他可以直接执行 SQL语句 ，就将员工的工资增加1000元。示例代码如下： from djang.db.models import F Employee.object.update(salary=F(&quot;salary&quot;)+1000) # 直接把sql传输到数据库!!!!! F表达式 并不会马上从数据库中获取数据，而是在生成 SQL 语句的时候，动态的获取传给 F表达式 的值。比如如果想要获取作者中， name 和 email 相同的作者数据。如果不使用 F表达式 ，那么需要使用以下代码来完成： authors = Author.objects.all() for author in authors: if author.name == author.email: print(author) 如果使用 F表达式 ，那么一行代码就可以搞定。示例代码如下： from django.db.models import F authors = Author.objects.filter(name=F(&quot;email&quot;)) # where email = name Q表达式：如果想要实现所有价格高于100元，并且评分达到9.0以上评分的图书。那么可以通过以下代码来实现： books = Book.objects.filter(price__gte=100,rating__gte=9) 以上这个案例是一个并集查询，可以简单的通过传递多个条件进去来实现。 但是如果想要实现一些复杂的查询语句，比如要查询所有价格低于10元，或者是评分低于9分的图书。那就没有办法通过传递多个条件进去实现了。这时候就需要使用 Q表达式 来实现了。示例代码如下： from django.db.models import Q books = Book.objects.filter(Q(price__lte=10) | Q(rating__lte=9)) 以上是进行或运算，当然还可以进行其他的运算，比如有 &amp; 和 ~（非） 等。一些用 Q 表达式的例子如下： from django.db.models import Q # 获取id等于3的图书 books = Book.objects.filter(Q(id=3)) # 获取id等于3，或者名字中包含文字&quot;记&quot;的图书 books = Book.objects.filter(Q(id=3)|Q(name__contains(&quot;记&quot;))) # 获取价格大于100，并且书名中包含&quot;记&quot;的图书 books = Book.objects.filter(Q(price__gte=100)&amp;Q(name__contains(&quot;记&quot;))) # 获取书名包含“记”，但是id不等于3的图书 books = Book.objects.filter(Q(name__contains=&#39;记&#39;) &amp; ~Q(id=3)) 日期# data 针对某些date或者datetime类型的字段。可以指定date的范围。并且这个时间过滤，还可以使用链式调用。示 例代码如下： articles = Article.objects.filter(pub_date__date=date(2018,3,29)) &#39;&#39;&#39; 以上代码的意思是查找时间为2018/3/29这一天发表的所有文章。 将翻译成以下的sql语句： select ... WHERE DATE(CONVERT_TZ(`front_article`.`pub_date`, &#39;UTC&#39;, &#39;Asia/Shanghai&#39;)) = 2018-03-29 注意，因为默认情况下MySQL的表中是没有存储时区相关的信息的。因此我们需要下载一些时区表的文件，然后添 加到Mysql的配置路径中。如果你用的是windows操作系统。那么在 http://dev.mysql.com/downloads/timezones.html下载timezone_2018d_posix.zip - POSIX standard。然后将下载下来的所有文件拷贝到C:\\ProgramData\\MySQL\\MySQL Server 5.7\\Data\\mysql 中，如果提示文件名重复，那么选择覆盖即可。 如果用的是linux或者mac系统，那么在命令行中执行以下命令：mysql_tzinfo_to_sql /usr/share/zoneinfo | mysql -D mysql -u root -p，然后输入密码，从系统中加载时区文件更新到 mysql中。 &#39;&#39;&#39; # year 根据年份进行查找 articles = Article.objects.filter(pub_date__year=2018) articles = Article.objects.filter(pub_date__year__gte=2017) &#39;&#39;&#39; 等价于: select ... where pub_date between &#39;2018-01-01&#39; and &#39;2018-12-31&#39;; select ... where pub_date &gt;= &#39;2017-01-01&#39;; &#39;&#39;&#39; # month 同year,根据月份查 # day 同year,根据日期查 # week_day Django 1.11新增的查找方式。同year，根据星期几进行查找。1表示星期天，7表示星期六，2-6代表的是星期一到星期五。 # time 根据时间查 articles = Article.objects.filter(pub_date__time=datetime.time(12,12,12)); # 以上的代码是获取每一天中12点12分12秒发表的所有文章。 更多的关于时间的过滤，请参考Django官方文档：https://docs.djangoproject.com/en/2.0/ref/models/querysets/#range。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Django简介","slug":"django简介","date":"2020-04-01T16:00:00.000Z","updated":"2020-04-21T02:28:51.183Z","comments":true,"path":"2020/04/02/django简介/","link":"","permalink":"/2020/04/02/django简介/","excerpt":"","text":"框架定义​ 软件框架（software framework），通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。简而言之，框架就是制定一套规范或者规则（思想），大家（程序员）在该规范或者规则（思想）下工作。或者说使用别人搭好的舞台来做编剧和表演。 Django的历史要了解一个东西，必须知道它的由来 Django 是从真实世界的应用中成长起来的，它是由堪萨斯（Kansas）州 Lawrence 城中的一个网络开发小组编写的。它诞生于 2003 年秋天，那时 Lawrence Journal-World 报纸的程序员 Adrian Holovaty 和 Simon Willison 开始用 Python 来编写程序。 当时他们的 World Online 小组制作并维护当地的几个新闻站点，并在以新闻界特有的快节奏开发环境中逐渐发展。这些站点包括有 LJWorld.com、Lawrence.com 和 KUsports.com，记者（或管理层） 要求增加的特征或整个程序都能在计划时间内快速的被建立，这些时间通常只有几天或几小时。因此，Adrian 和 Simon 开发了一种节省时间的网络程序开发框架，这是在截止时间前能完成程序的唯一途径。 2005 年的夏天，当这个框架开发完成时，它已经用来制作了很多个 World Online 的站点。当时 World Online 小组中的 Jacob Kaplan-Moss 决定把这个框架发布为一个开源软件。 从今往后数年，Django是一个有着数以万计的用户和贡献者，在世界广泛传播的完善开源项目。原来的World Online的两个开发者（Adrian and Jacob）仍然掌握着Django，但是其发展方向受社区团队的影响更大。这些历史都是相关联的，因为她们帮助解释了很重要的两点。 第一，Django最可爱的地方。Django 诞生于新闻网站的环境中，因此它提供很多了特性（如管理后台），非常适合内容类的网站（不要看到这就感到沮丧，尽管Django擅长于动态内容管理系统，但并不表示Django主要的目的就是用来创建动态内容的网站。某些方面特别高效与其他方面不高效是有区别的，Django在其他方面也同样高效。） 第二，Django的起源造就了它的开源社区的文化。因为Django来自于真实世界中的代码，而不是来自于一个科研项目或者商业产品，她主要集中力量来解决Web开发中遇到的问题，同样也是Django的开发者经常遇到的问题。这样，Django每天在现有的基础上进步。框架的开发者对于让开发人员节省时间，编写更加容易维护的程序，同时保证程序运行的效率具有极大的兴趣。无他，开发者动力来源于自己的目标：节省时间，快乐工作。 Django由哪几部分组成 用于进行数据持久化的ORM模块 用于进行URL地址分配的路由模块 用于进行模板页面处理的模板系统 用于进行表单操作的表单模型 用于进行性能突破的缓存系统专业术语解释持久化：数据永久的保存的过程称为数据的持久化ORM：将程序中的对象[Object]和数据库中的表[Relation]建立关联关系[Mapping]的过程称为ORM路由：模拟生活中的路由器，将请求URL地址和对应的函数进行关联的操作称为路由 Django的架构模式关于软件架构模式，我们要从MVC说起 MVC架构模式mvc是由美国的施乐公司（代表产品是打印机、复印机产业）旗下的帕罗奥多研究中心一位程序员发明了smalltalk语言（第二个面向对象的语言），simula67（第一个面向对象的语言） MVC的产生理念：分开。专门的人做专门的事（像公司中各部门一样，不同的部门做着不同的事） MVC的核心思想：解藕。（例如：电脑硬盘坏了，不需要把整个电脑换掉，只需要把硬盘换了，就可以正常使用了。） MVC是一种使用MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式： Model（模型）表示应用程序核心（比如数据库记录列表）。 View（视图）显示数据（数据库记录）。 Controller（控制器）处理输入（写入数据库记录）。 MVT架构模式​ Django在处理的过程中，对于经典的MVC处理模式并不是非常认同，在实际项目开发过程中控制器Controller起到的作用非常的有限，所以Django将控制器部分也进行了封装，但是同时扩展了视图View部分，增加了模板功能实现了前端网页的复用，所以Django的架构模式更加符合MVT处理模式 M:model数据模型 V:View视图 T:Template模板","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Django + Vue 跨域","slug":"Django + Vue 跨域","date":"2020-04-01T16:00:00.000Z","updated":"2020-04-21T02:28:46.094Z","comments":true,"path":"2020/04/02/Django + Vue 跨域/","link":"","permalink":"/2020/04/02/Django + Vue 跨域/","excerpt":"","text":"解决跨域问题——django解决方案1、安装django-core-headers pip install django-core-headers 2、配置settings文件 加入到INSTALLED_APPS下面 INSTALLED_APPS = [ # 第三方框架 &#39;corsheaders&#39;, # 解决跨域问题 ] 配置MIDDLEWARE中间件，放在SessionMiddleware和CommonMiddleware中间。 MIDDLEWARE = [ &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;, &#39;corsheaders.middleware.CorsMiddleware&#39;, # 解决跨域问题，必须放在这个位置，加载顺序 &#39;django.middleware.common.CommonMiddleware&#39;, ] 配置允许跨域访问的域名 CORS_ORIGIN_ALLOW_ALL = True # 解决跨域，配置允许跨域访问的域名，为True时，允许所有的域名 注意：这三项都是在django项目下的seetings中配置的 解决跨域问题——VUE解决方案proxyTable: { &#39;/api&#39;: { //使用&quot;/api&quot;来代替&quot;http://f.apiplus.c&quot; target: &#39;http://127.0.0.1:8000/&#39;, //源地址 changeOrigin: true, //改变源 pathRewrite: { &#39;^/api&#39;: &#39;&#39; //路径重写 } } } 安装axios1、安装axios cnpm install --save axios 2、配制axios,在src文件下的mian.js中配制 import axios from &#39;axios&#39; Vue.prototype.axios = axios 3、axios使用 axios完整写法： this.axios({ method: &#39;post&#39;, url: &#39;/user/12345&#39;, data: { firstName: &#39;Fred&#39;, lastName: &#39;Flintstone&#39; } }).then((res)=&gt;{ console.log(res) }).catch((error)=&gt;{ console.log(error) }); post请求 this.axios.post(&#39;&#39;,{}).then((res)=&gt;{}).catch((error)=&gt;{}) get请求 &lt;script&gt; import Vue from &#39;vue&#39; import axios from &#39;axios&#39; export default{ name: &#39;card&#39;, mounted:function () { //vue页面加载时自动执行 this.send() }, data:{ url_array: [] }, methods:{ send(){ var self = this axios({ method:&#39;get&#39;, url:&#39;http://127.0.0.1:8000/myapp/api_type/&#39; }).then(function(res){ console.log(res.data.li_list); self.url_array = res.data.li_list console.log(self.url_array) }); } } } &lt;/script&gt;","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"创建虚拟环境","slug":"虚拟环境","date":"2020-03-31T16:00:00.000Z","updated":"2020-04-21T02:28:40.660Z","comments":true,"path":"2020/04/01/虚拟环境/","link":"","permalink":"/2020/04/01/虚拟环境/","excerpt":"","text":"虚拟环境为什么需要虚拟环境：到目前位置，我们所有的第三方包安装都是直接通过pip install xx的方式进行安装的，这样安装会将那个包安装到你的系统级的Python环境中。但是这样有一个问题，就是如果你现在用Django 1.18.x写了个网站，然后你的领导跟你说，之前有一个旧项目是用Django 2.1.x开发的，让你来维护，但是Django 1.18.x不再兼容Django 2.1.x的一些语法了。这时候就会碰到一个问题，我如何在我的电脑中同时拥有Django 1.18.x和Django 2.1.x两套环境呢？这时候我们就可以通过虚拟环境来解决这个问题。 虚拟环境原理介绍：虚拟环境相当于一个抽屉，在这个抽屉中安装的任何软件包都不会影响到其他抽屉。并且在项目中，我可以指定这个项目的虚拟环境来配合我的项目。比如我们现在有一个项目是基于Django 1.18.x版本，又有一个项目是基于Django 2.1.x的版本，那么这时候就可以创建两个虚拟环境，在这两个虚拟环境中分别安装Django 1.18.x和Django 2.1.x来适配我们的项目。 安装virtualenv：virtualenv是用来创建虚拟环境的软件工具，我们可以通过pip或者pip3来安装： pip install virtualenv pip3 install virtualenv # 一般在linux下用这个命令 pip install virtualenvwrapper #windows下 更改虚拟环境路径 添加环境变量 在python的安装路径下script下，找到mkvirtualenv.bat文件 修改其中的第24行内容 创建虚拟环境：创建虚拟环境非常简单，通过以下命令就可以创建了： # mkvirtualenv [虚拟环境的名字] mkvirtualenv py_dj2 如果你当前的Python3/Scripts的查找路径在Python2/Scripts的前面，那么将会使用python3作为这个虚拟环境的解释器。如果python2/Scripts在python3/Scripts前面，那么将会使用Python2来作为这个虚拟环境的解释器。 进入环境：虚拟环境创建好了以后，那么可以进入到这个虚拟环境中，然后安装一些第三方包，进入虚拟环境在不同的操作系统中有不同的方式，一般分为两种，第一种是Windows，第二种是Linux： windows进入虚拟环境：进入到虚拟环境的Scripts文件夹中，然后执行activate。 Linux进入虚拟环境：source /path/to/virtualenv/bin/activate一旦你进入到了这个虚拟环境中，你安装包，卸载包都是在这个虚拟环境中，不会影响到外面的环境。 退出虚拟环境：退出虚拟环境很简单，通过一个命令就可以完成：deactivate。 virtualenvwrapper：virtualenvwrapper这个软件包可以让我们管理虚拟环境变得更加简单。不用再跑到某个目录下通过virtualenv来创建虚拟环境，并且激活的时候也要跑到具体的目录下去激活。 安装virtualenvwrapper： Linux：pip install virtualenvwrapper。 windows：pip install virtualenvwrapper-win。 virtualenvwrapper基本使用： 创建虚拟环境： mkvirtualenv my_env 那么会在你当前用户下创建一个Env的文件夹，然后将这个虚拟环境安装到这个目录下。如果你电脑中安装了python2和python3，并且两个版本中都安装了virtualenvwrapper，那么将会使用环境变量中第一个出现的Python版本来作为这个虚拟环境的Python解释器。 切换到某个虚拟环境： workon my_env 退出当前虚拟环境： deactivate 删除某个虚拟环境： rmvirtualenv my_env 列出所有虚拟环境： lsvirtualenv 创建虚拟环境的时候指定Python版本： 在使用mkvirtualenv的时候，可以指定--python的参数来指定具体的python路径： mkvirtualenv --python==C:\\Python36\\python.exe hy_env","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"个人简历","slug":"个人简历","date":"2020-03-31T16:00:00.000Z","updated":"2020-04-21T02:28:24.254Z","comments":true,"path":"2020/04/01/个人简历/","link":"","permalink":"/2020/04/01/个人简历/","excerpt":"","text":"个人简历个人基本信息姓 名： 周磊 性 别： 男 联系方式：13935876263 E-mail：zhou956973503@gmail.com 学历：国家开放大学 统招本科 求职意向： python web后端开发 二年的Python开发经验，熟练使用Django框架等后端框架，了解Vue.js的前端框架，熟悉MySQL,redis 数据库，曾参与项目核心模块的开发。优秀的学习能力和团队沟通能力能更快的融入团队开发中去，经常和团队进行技术分享，和团队共同进步。 开发技能后端框架：Django 前端框架：Vue.js 数据库：Mysql，Redis，MongoDB 其他：MarkDown, VS code, PyCharm 工作经历2018.10– 至今 新锐泰乐科技有限公司 Python全栈开发工程师 2017.8–2018.10 思铭博达科技科技有限公司 Python初级开发工程师","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"hello-world","slug":"hello-world","date":"2018-12-20T15:13:48.000Z","updated":"2020-04-20T13:43:05.837Z","comments":true,"path":"2018/12/20/hello-world/","link":"","permalink":"/2018/12/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-11T16:00:00.000Z","updated":"2020-04-21T02:29:10.181Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}