{"meta":{"title":"Zhou","subtitle":null,"description":"好少年光芒万丈","author":"Zhou","url":"https://zhoulei.icu"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-04-18T11:47:51.150Z","comments":false,"path":"about/index.html","permalink":"https://zhoulei.icu/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-04-18T11:47:51.151Z","comments":false,"path":"bangumi/index.html","permalink":"https://zhoulei.icu/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-04-18T11:47:51.152Z","comments":false,"path":"donate/index.html","permalink":"https://zhoulei.icu/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-04-18T11:47:51.152Z","comments":false,"path":"lab/index.html","permalink":"https://zhoulei.icu/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-04-21T06:29:21.907Z","comments":false,"path":"music/index.html","permalink":"https://zhoulei.icu/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-04-18T11:47:51.153Z","comments":true,"path":"rss/index.html","permalink":"https://zhoulei.icu/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-04-18T11:47:51.154Z","comments":true,"path":"tags/index.html","permalink":"https://zhoulei.icu/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-04-18T11:47:51.154Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://zhoulei.icu/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-04-18T11:47:51.151Z","comments":false,"path":"client/index.html","permalink":"https://zhoulei.icu/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-09-02T07:44:12.734Z","comments":true,"path":"links/index.html","permalink":"https://zhoulei.icu/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-04-18T11:47:51.151Z","comments":true,"path":"comment/index.html","permalink":"https://zhoulei.icu/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-04-18T11:47:51.154Z","comments":false,"path":"video/index.html","permalink":"https://zhoulei.icu/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"django2.0.4设置缓存实现图片验证码","slug":"django2.0.4设置缓存实现图片验证码","date":"2020-08-16T16:00:00.000Z","updated":"2020-08-17T12:12:11.145Z","comments":true,"path":"2020/08/17/django2.0.4设置缓存实现图片验证码/","link":"","permalink":"https://zhoulei.icu/2020/08/17/django2.0.4设置缓存实现图片验证码/","excerpt":"","text":"先下载生成图片验证码的压缩包 链接：https://pan.baidu.com/s/1JqE5sKv1GL4Fp90fJTnZAw提取码：5wql 下载好后解压到自己的django项目中 安装pip install django-redis 配置settings.py# 缓存配置 CACHES = { &quot;default&quot;: { # 默认存缓位置 &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;, &quot;LOCATION&quot;: &quot;redis://127.0.0.1:6379/0&quot;, &quot;OPTIONS&quot;: { &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;, } }, &quot;session&quot;: { # 存session &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;, &quot;LOCATION&quot;: &quot;redis://127.0.0.1:6379/1&quot;, &quot;OPTIONS&quot;: { &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;, } }, &quot;verify_code&quot;: { # 图形验证码, 短信验证码 &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;, &quot;LOCATION&quot;: &quot;redis://127.0.0.1:6379/2&quot;, &quot;OPTIONS&quot;: { &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;, } } } # 配置session使用redis存储 SESSION_ENGINE = &quot;django.contrib.sessions.backends.cache&quot; # 配置session存储的位置: 使用cache中的 session配置 SESSION_CACHE_ALIAS = &quot;session&quot; views.py1. 导入包 captcha 2. 解压到 lib/captcha 3. 编写视图返回验证图片 # verifications/views.py from django.http import HttpResponse, HttpResponseForbidden from django.views import View from django_redis import get_redis_connection from libs.captcha.captcha import captcha #将刚才解压后的代码导入 class ImageCodeView(View): def get(self, request): # 1, 接收数据 uuid为前端传的参数 uuid = request.GET.get(&#39;uuid&#39;) # 2, 校验数据 if not uuid: return HttpResponseForbidden(&#39;uuid无效&#39;) # 3, 处理业务 # 获取图片文本内容和图片二进制代码 text, image = captcha.generate_captcha() # 把uuid和图片文本存入redis # 获取redis客户端 redis_client = get_redis_connection(&#39;verify_code&#39;) # 写入redis redis_client.setex(uuid, 60 * 5, text) # 4, 返回响应 return HttpResponse(image, content_type=&#39;image/jpg&#39;) urls.py# 增加路由 from django.urls import path from . import views urlpatterns = [ path(&#39;image_codes/&#39;, views.ImageCodeView.as_view()) ] 浏览器中测试的地址http://127.0.0.1:8000/image_codes/?uuid=123qwe #因为只测试后端，所以uuid先自行定义","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"django","slug":"django","permalink":"https://zhoulei.icu/tags/django/"},{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"django2.0.4使用容联云发送短信验证码","slug":"django2.0.4使用容联云发送短信验证码","date":"2020-08-14T16:00:00.000Z","updated":"2020-08-17T12:06:23.638Z","comments":true,"path":"2020/08/15/django2.0.4使用容联云发送短信验证码/","link":"","permalink":"https://zhoulei.icu/2020/08/15/django2.0.4使用容联云发送短信验证码/","excerpt":"","text":"使用容联云登陆并注册https://www.yuntongxun.com/user/login 保存好自己的信息 设置测试号码 代码编写安装容联云sdkpip install ronglian_sms_sdk 免费测试文档地址:https://doc.yuntongxun.com/p/5a531a353b8496dd00dcdfe2 from ronglian_sms_sdk import SmsSDK #设置自己的信息 accId = &#39;***********************&#39; accToken = &#39;***********************&#39; appId = &#39;***********************&#39; def send_message(phone, datas): sdk = SmsSDK(accId, accToken, appId) tid = &#39;1&#39; # 测试模板id为: 1. 内容为: 【云通讯】您的验证码是{1}，请于{2}分钟内正确输入。 # mobile = &#39;13303479527&#39; # datas = (&#39;666777&#39;, &#39;5&#39;) # 模板中的参数按照位置传递，第一个是验证码，第二个是有效时间 resp = sdk.sendMessage(tid, phone, datas) resp_dict = json.loads(resp) if resp_dict.get(&#39;statusCode&#39;) == &#39;000000&#39;: return &#39;0&#39; #发送失败返回-1 return &#39;-1&#39;","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"django","slug":"django","permalink":"https://zhoulei.icu/tags/django/"},{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"Django2.0.4+Vue2.0实现Gitee三方登陆","slug":"django2.0.4+vue2.0实现gitee三方登陆","date":"2020-07-31T16:00:00.000Z","updated":"2020-08-06T06:35:51.586Z","comments":true,"path":"2020/08/01/django2.0.4+vue2.0实现gitee三方登陆/","link":"","permalink":"https://zhoulei.icu/2020/08/01/django2.0.4+vue2.0实现gitee三方登陆/","excerpt":"","text":"登陆Gitee1.点击自己的头像进入设置页面2.创建应用 3.填写应用相关信息，勾选应用所需要的权限。其中: 回调地址是用户授权后，码云回调到应用，并且回传授权码的地址 应用主页：要求不严格，测试用的话可以直接填http://127.0.0.1:8000/ 应用回调地址 ：这里要填写自己定义的视图路由，我自己的为http://127.0.0.1:8000/gitee_back 4.创建成功后，会生成 Cliend ID 和 Client Secret。他们将会在上述OAuth2 认证基本流程用到 vue代码这里只写一个点击方法 //gitee登陆 gitee:function(){ //创建应用后生成的Cliend ID var clientId = &#39;*********************************&#39; //应用回调地址 var redirect_uri = &#39;http://127.0.0.1:8000/gitee_back&#39; //拼接要请求的地址 var url = &#39;https://gitee.com/oauth/authorize?client_id=&#39;+clientId+&#39;&amp;redirect_uri=&#39;+redirect_uri+&#39;&amp;response_type=code&#39; // 进行跳转 window.location.href = url; }, django代码views.py from django.shortcuts import redirect import requests import json #gitee三方登陆 class Gitee(APIView): def get(self,request): #获取gitee给的code code = request.GET.get(&#39;code&#39;) #自己的client_id client_id = &#39;*********************************&#39; #client_secret client_secret=&#39;******************************************8&#39; #应用回调地址 redirect_uri=&#39;http://127.0.0.1:8000/gitee_back&#39; #拼接请求地址 res = requests.post(&#39;https://gitee.com/oauth/token?grant_type=authorization_code&amp;code=&#39;+code+&#39;&amp;client_id=&#39;+client_id+&#39;&amp;redirect_uri=&#39;+redirect_uri+&#39;&amp;client_secret=&#39;+client_secret) #拿到请求后获取的信息 res = json.loads(res.text) #获取access_token token = res[&#39;access_token&#39;] #将access_token参数带上请求此地址，可以获取到用户信息 message = requests.get(&#39;https://gitee.com/api/v5/user?access_token=&#39;+token) mess = json.loads(message.text) username = mess[&#39;login&#39;] user = User.objects.filter(username = username).first() if user: username = user.username uid = user.id else: user = User.objects.create(username=username,password=md5(&#39;123456&#39;.encode(&#39;utf-8&#39;)).hexdigest()) username = user.username uid = user.id #直接重定向到前端地址，可以带上用户的信息，由前端接收并存储 return redirect(&#39;http://127.0.0.1:8080/courses&#39;) urls.py from django.contrib import admin from django.urls import path from django.conf.urls import url from django.urls import path,re_path from django.views.static import serve #按自己的路径将视图导入 from myapp.views import Gitee urlpatterns = [ #此处的路由一定要和自己定义的回调地址相同 path(&#39;gitee_back/&#39;, Gitee.as_view()), ] 参考地址https://gitee.com/api/v5/oauth_doc#/list-item-0","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"django","slug":"django","permalink":"https://zhoulei.icu/tags/django/"},{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"微服务","slug":"微服务","date":"2020-07-29T16:00:00.000Z","updated":"2020-08-05T08:42:11.244Z","comments":true,"path":"2020/07/30/微服务/","link":"","permalink":"https://zhoulei.icu/2020/07/30/微服务/","excerpt":"","text":"诞生背景微服务（Microservice）这个概念是2012年出现的，作为加快Web和移动应用程序开发进程的一种方法，2014年开始受到各方的关注，而2015年，可以说是微服务的元年； 越来越多的论坛、社区、blog以及互联网行业巨头开始对微服务进行讨论、实践，可以说这样更近一步推动了微服务的发展和创新。而微服务的流行，Martin Fowler功不可没。 互联网的快速发展 敏捷开发 精益方法的深入人心 容器技术的成熟 传统的项目架构？优点： 开发简单，集中式管理 基本不会重复开发 功能都在本地，没有分布式的管理和调用消耗 缺点： 效率低：开发都在同一个项目改代码，相互等待，冲突不断 维护难：代码功功能耦合在一起，新人不知道何从下手 不灵活：构建时间长，任何小修改都要重构整个项目，耗时 稳定性差：一个微小的问题，都可能导致整个应用挂掉 扩展性不够：无法满足高并发下的业务需求 常见的系统架构遵循的三个标准和业务驱动力： 提高敏捷性：及时响应业务需求，促进企业发展 提升用户体验：提升用户体验，减少用户流失 降低成本：降低增加产品、客户或业务方案的成本 现在我们来看一下微服务必须需要的原则？1，单一功能职责 单一功能职责是SOLID设计模式之一，它意味着一个单元，无论是类、函数还是微服务，都应该有且只有一个职责。在任何时候，一个微服务都不应该有一个以上的职责。 自己查看SOLID Pass 2，围绕着业务功能设计 微服务应该专注于特定的业务功能，并确保它有助于完成任务。微服务绝不应限制自己采用最适合解决业务目的的适当技术栈或后端数据库存储。当我们设计单个应用程序时，这常常是一个约束，我们试图在某些领域中使用一些折中来解决多个业务解决方案。微服务使您能够选择最适合当前问题的解决方案。（某个微服务不仅仅只为一个微服务来服务，他要为其他的微服务提供支持，也就是全局的架构） 3，你建造它，你拥有它。这种设计的另一个重要方面与开发前后的职责有关。在大型组织中，通常由一个团队开发app location(应用)，经过一些知识转移会议后，将项目移交给维护团队。在微服务中，构建服务的团队拥有它，并负责在将来维护它。这使开发人员能够接触到他们的软件的日常操作，并且他们能够更好地理解他们构建的产品在现实世界中是如何被客户使用的。 4，基础设施自动化准备和构建微服务的基础设施是另一个非常重要的需求，服务应该是可独立部署的，并且应该捆绑所有依赖项，包括库依赖项，甚至是执行环境，如抽象物理资源（web服务器和容器或虚拟机）。 微服务和SOA之间的一个主要区别在于它们的自治级别。虽然大多数SOA实现提供了服务级抽象，但是微服务更进一步抽象了实现和执行环境。 在传统的应用程序开发中，我们构建一个WAR或EAR，然后将其部署到JEE应用程序服务器中，例如使用JBoss、WebLogic、WebSphere等等。我们可以将多个应用程序部署到同一个JEE容器中。在理想的场景中，在微服务方法中，每个微服务将构建为一个胖Jar，嵌入所有依赖项，并作为独立的Java进程运行。 5，容错设计微服务的设计应考虑到故障情况。如果服务失败，或者宕机一段时间，该怎么办?这些都是非常重要的问题，必须在实际编码开始之前解决——以便清楚地估计服务故障将如何影响用户体验。 快速故障是另一个用于构建容错、弹性系统的概念。这种哲学提倡预期失败的系统，而不是构建永远不会失败的系统。由于服务在任何时候都可能失败，因此能够快速检测故障并在可能的情况下自动恢复服务非常重要。 微服务应用程序非常重视应用程序的实时监控，检查体系结构元素(数据库每秒接收多少请求)和业务相关指标(例如每分钟接收多少订单)。语义监视可以提供出错的早期预警系统，从而触发开发团队进行跟踪和调查。 微服务的目的？目的：有效的拆分应用，实现敏捷开发和部署 微服务的优点 ？微服务有许多优点相比传统的多层架构（单体庞大应用），微服务的优点如下： 使用微服务，架构师和开发人员可以为每个微服务选择适合于特定用途的架构和技术(通晓多种语言对应的熟悉语言的架构)。这为以更经济有效的方式设计更适合的解决方案提供了灵活性。 由于服务相当简单，而且规模更小，企业可以试验新的流程、算法、业务逻辑等等。它通过提供快速试验和失败的能力，使企业能够进行颠覆性创新。 微服务能够实现选择性的可伸缩性，即每个服务都可以独立地伸缩，而且伸缩的成本相对于单体应用方面要低。 微服务是自包含的、独立的部署模块，当第二个微服务没有按照我们的需要执行时，可以使用另一个类似的微服务替换一个微服务。它有助于做出正确的“购买构建”决策，而这通常是许多企业面临的挑战。 微服务帮助我们构建本质上是有机的系统(有机的系统是通过添加越来越多的功能在一段时间内横向增长的系统)。因为微服务都是关于独立可管理的服务——它允许在需要时添加越来越多的服务，而对现有服务的影响最小。 技术变化是软件开发中的障碍之一。使用微服务，可以单独更改或升级每个服务的技术，而不是升级整个应用程序。 由于microservices将服务运行时环境和服务本身打包在一起，因此允许在同一环境中共存多个版本的服务。 最后，微服务还支持更小、更专注的敏捷开发团队。团队将根据微服务的边界进行组织。","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"Django中间件","slug":"Django中间件","date":"2020-07-27T16:00:00.000Z","updated":"2020-08-05T08:35:19.953Z","comments":true,"path":"2020/07/28/Django中间件/","link":"","permalink":"https://zhoulei.icu/2020/07/28/Django中间件/","excerpt":"","text":"什么是中间件？ 中间件是一个用来处理Django的请求和响应的框架级别的钩子。它是一个轻量、低级别的插件系统，用于在全局范围内改变Django的输入和输出。每个中间件组件负责做一些特定的功能。 由于其影响的是全局，所以需要谨慎使用，使用不当会影响性能。 说的直白一点，中间件可以帮助我们在视图函数执行之前和执行之后做一些额外的操作。 它的本质是一个自定义类，类中定义了几个方法，Django框架会在请求的特定时间去执行这些方法。 中间件的五种方法： process_request(self, request) process_view(self, request, view_func, view_args, view_kwargs) process_template_response(self, request, response) process_exception(self, request, exception) process_response(self, request, response) 当Django处理一个 Request 的过程是首先通过中间件，然后再通过默认的 URL 方式进行的。我们可以在 Middleware 这个地方把所有Request 拦截住，用我们自己的方式完成处理以后直接返回 Response。因此了解中间件的构成是非常必要的。 在django项目的settings模块中，有一个 MIDDLEWARE_CLASSES 变量，其中每一个元素就是一个中间件，如下图： django 拥有的中间件中的五个方法，具体如下： 1 Request预处理函数: process_request(self, request) 这个方法的调用时机在Django接收到request之后，但仍未解析URL以确定应当运行的视图函数。Django向它传入相应的Request对象，以便在方法中修改。 如果返回None，Django将继续处理这个request，执行后续的中间件， 然后调用相应的 view。 如果返回HttpResponse对象，Django将不再执行任何除了process_response以外其它的中间件以及相应的view，Django将立即返回该HttpResponse。 process_request: 如果验证失败，直接返回Httpresponse,所有的不在继续执行2 View预处理函数: process_view(self, request, callback, callback_args,callback_kwargs) 这个方法的调用时机在 Django 执行完 request 预处理函数并确定待执行的 view （即callback参数）之后，但在 view 函数实际执行之前。 request：HttpRequest 对象。 callback：Django将调用的处理request的python函数. 这是实际的函数对象本身, 而不是字符串表述的函数名。 args：将传入view的位置参数列表，但不包括request参数(它通常是传入view的第一个参数)。 kwargs：将传入view的关键字参数字典。 process_view() 应当返回None或 HttpResponse 对象。如果返回 None， Django将继续处理这个request ，执行后续的中间件， 然后调用相应的view。 如果返回 HttpResponse 对象，Django 将不再执行任何其它的中间件(不论种类)以及相应的view，Django将立即返回。 request 通过，view 没有通过，往下不继续执行3 Template**模版渲染函数：**process_template_response() 默认不执行，只有在视图函数的返回结果对象中有render方法才会执行，并把对象的render方法的返回值返回给用户（注意不返回视图函数的return的结果了，而是返回视图函数 return值（对象）中rende方法的结果） request——-&gt;view———Template(默认的不执行，除非有关键字的render(返回值（return）))4 Exception后处理函数:process_exception(self, request, exception) 触发机制？Try except 这个方法只有在 request 处理过程中出了问题并且view 函数抛出了一个未捕获的异常时才会被调用。 作用？@装饰器的使用 这个钩子可以用来发送错误通知，将现场相关信息输出到日志文件，或者甚至尝试从错误中自动恢复。 这个函数的参数除了一贯的request对象之外，还包括view函数抛出的实际的异常对象exception 。 process_exception() 应当返回None或HttpResponse对象。 如果返回None，Django将用框架内置的异常处理机制继续处理相应request。 如果返回HttpResponse对象，Django将使用该response对象，而短路框架内置的异常处理机制。 捕获到错误5 Response后处理函数:process_response(self, request, response) Import json(dump, dumps, load, loads) Import pickle(同json) process_response 函数是执行完 views.py 后执行的函数 process_response 函数有两个参数，一个是 request，一个是 response，response 是视图函数返回的响应对象 process_response 函数的返回值必须是 HttpResponse 对象 这个方法的调用时机在 Django 执行 view 函数并生成 response 之后。 该中间件能修改response 的内容，常见的操作是什么？ 一个常见的用途是内容压缩，如gzip所请求的HTML页面。 这个方法的参数相当直观：request是request对象，而response则是从view中返回的response对象。 process_response() 必须返回 HttpResponse 对象. 这个 response 对象可以是传入函数的那一个原始对象（通常已被修改），也可以是全新生成的。 Hasattr(某个类是否有这个属性) getattr（获取某个类的属性） setattr（给某个类设置属性） 如上图，分析源码得知前二个方法是从前往后执行的，后三个方法是从后往前执行的 。所以前两个方法是请求进来时要经过的流程的，而后三个方法是请求出去时要经过的的，具体流程如下： 自定义中间件要注意以下事项： 1、process_response一定要有return否则会报错，自定义的中间件response方法没有return，会交给下一个中间件，导致http请求中断了。 2.1、process_view（self, request, callback,callback_args, callback_kwargs）方法介绍： (1)执行完所有中间件的process_request方法‘ (2) url匹配成功 (3)拿到视图函数的名称、参数，（注意不执行）再执行process_view()方法 (4)最后去执行视图函数 2.2、既然process_view 拿到视图函数的名称、参数，（不执行） 再执行process_view()方法，最后才去执行视图函数，所以可以在执行process_view环节时直接把函数执行进行return返回。注意：此时的process_view2将不再被调用执行，而是直接跳转到最后一个中间件， 执行最后一个中间件的response方法，逐步返回。 3、process_template_response方法默认也不会执行，只有在视图函数的返回对象中有render方法才会执行.并把对象的render方法的返回值返回给用户（注意不返回视图函数的return的结果了，而是返这个结果对象里render方法的返回值，并且process_template_response方法也要返回response不然会报错。 4、添加process_exception方法后发现在函数正常执行情况下该方法不会被调用 （1）执行完所有 request 方法； （2）执行所有 process_view方法； （3）如果视图函数出错，执行process_exception方法，如果第一个中间件的process_exception方法有了返回值就不再执行其他中间件process_exception，直接执行response方法； （4）执行所有response方法； 最后返回process_exception的返回值","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"django","slug":"django","permalink":"https://zhoulei.icu/tags/django/"},{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"高并发的解决方案","slug":"高并发的解决方案","date":"2020-07-26T16:00:00.000Z","updated":"2020-08-05T08:35:06.181Z","comments":true,"path":"2020/07/27/高并发的解决方案/","link":"","permalink":"https://zhoulei.icu/2020/07/27/高并发的解决方案/","excerpt":"","text":"日活是什么？日活一般指DAU。DAU(Daily Active User)日活跃用户数量。常用于反映网站、互联网应用或网络游戏的运营情况。DAU通常统计一日（统计日）之内，登录或使用了某个产品的用户数（去除重复登录的用户），这与流量统计工具里的访客（UV）概念相似 pv 是什么PV（Page View）访问量, 即页面浏览量或点击量，衡量网站用户访问的网页数量；在一定统计周期内用户每打开或刷新一个页面就记录1次，多次打开或刷新同一页面则浏览量累计 uv 是什么？UV（Unique Visitor）独立访客，统计1天内访问某站点的用户数(以cookie为依据);访问网站的一台电脑客户端为一个访客。可以理解成访问某网站的电脑的数量。网站判断来访电脑的身份是通过来访电脑的cookies实现的。如果更换了IP后但不清除cookies，再访问相同网站，该网站的统计中UV数是不变的。如果用户不保存cookies访问、清除了cookies或者更换设备访问，计数会加1。00:00-24:00内相同的客户端多次访问只计为1个访客。 Qps是什么？每秒查询率（QPS，Queries-per-second）是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量 一、什么是高并发 高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。 高并发相关常用的一些指标有响应时间（Response Time），吞吐量（Throughput），每秒查询率QPS（Query Per Second），并发用户数等。 响应时间：系统对请求做出响应的时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间。 吞吐量：单位时间内处理的请求数量。 QPS：每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。 并发用户数：同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。 前端：页面的缓存，动静资源的分离（静态页面，建立一个图片服务器）——————cdn 加速（） 二、如何提升系统的并发能力 互联网分布式架构设计，提高系统并发能力的方式，方法论上主要有两种：垂直扩展（Scale Up）与水平扩展（Scale Out）。 垂直扩展：提升单机处理能力。垂直扩展的方式又有两种： （1）增强单机硬件性能，例如：增加CPU核数如32核，升级更好的网卡如万兆，升级更好的硬盘如SSD，扩充硬盘容量如2T，扩充系统内存如128G； （2）提升单机架构性能，例如：使用Cache来减少IO次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间； 在互联网业务发展非常迅猛的早期，如果预算不是问题，强烈建议使用“增强单机硬件性能”的方式提升系统并发能力，因为这个阶段，公司的战略往往是发展业务抢时间，而“增强单机硬件性能”往往是最快的方法。 不管是提升单机硬件性能，还是提升单机架构性能，都有一个致命的不足：单机性能总是有极限的。所以互联网分布式架构设计高并发终极解决方案还是水平扩展。 现在是一个团队时代，集群方案考虑一下水平扩展：只要增加服务器数量，就能线性扩充系统性能。水平扩展对系统架构设计是有要求的，如何在架构各层进行可水平扩展的设计，以及互联网公司架构各层常见的水平扩展实践，是本文重点讨论的内容。 三、常见的互联网分层架构 常见互联网分布式架构如上，分为： （1）客户端层：典型调用方是浏览器browser或者手机应用APP （2）反向代理层：系统入口，反向代理（nginx,轮询查看，根据算法ip，分发到指定的服务器） （3）站点应用层：实现核心应用逻辑，返回html或者json，（算法的实现，能用o(1）绝不用o(n)以上） （4）数据-缓存层：缓存加速访问存储(redis) （5）数据-数据库层：数据库固化数据存储(mysql的优化) 整个系统各层次的水平扩展，又分别是如何实施的呢？ 四、分层水平扩展架构实践 反向代理层的水平扩展 反向代理层的水平扩展，是通过“DNS轮询”实现的：dns-server对于一个域名配置了多个解析ip，每次DNS解析请求来访问dns-server，会轮询返回这些ip。 当nginx成为瓶颈的时候，只要增加服务器数量，新增nginx服务的部署，增加一个外网ip，就能扩展反向代理层的性能，做到理论上的无限高并发。 站点层的水平扩展 站点层的水平扩展，是通过“nginx”实现的。通过修改nginx.conf，可以设置多个web后端。 当web后端成为瓶颈的时候，只要增加服务器数量，新增web服务的部署，在nginx配置中配置上新的web后端，就能扩展站点层的性能，做到理论上的无限高并发。 服务层的水平扩展 服务层的水平扩展，是通过“服务连接池”实现的。 站点层通过RPC-client调用下游的服务层RPC-server时，RPC-client中的连接池会建立与下游服务多个连接，当服务成为瓶颈的时候，只要增加服务器数量，新增服务部署，在RPC-client处建立新的下游服务连接，就能扩展服务层性能，做到理论上的无限高并发。如果需要优雅的进行服务层自动扩容，这里可能需要配置中心里服务自动发现功能的支持。 数据层的水平扩展 在数据量很大的情况下，数据层（缓存，数据库）涉及数据的水平扩展，将原本存储在一台服务器上的数据（缓存，数据库）水平拆分到不同服务器上去，以达到扩充系统性能的目的。 互联网数据层常见的水平拆分方式有这么几种，以数据库为例： 按照范围水平拆分 每一个数据服务，存储一定范围的数据，上图为例： user0库，存储uid范围1-1kw user1库，存储uid范围1kw-2kw 这个方案的好处是： （1）规则简单，service只需判断一下uid范围就能路由到对应的存储服务； （2）数据均衡性较好； （3）比较容易扩展，可以随时加一个uid[2kw,3kw]的数据服务； 不足是： （1） 请求的负载不一定均衡，一般来说，新注册的用户会比老用户更活跃，大range的服务请求压力会更大； 按照哈希水平拆分 每一个数据库，存储某个key值hash后的部分数据，上图为例： user0库，存储偶数uid数据 user1库，存储奇数uid数据 这个方案的好处是： （1）规则简单，service只需对uid进行hash能路由到对应的存储服务； （2）数据均衡性较好； （3）请求均匀性较好； 不足是： （1）不容易扩展，扩展一个数据服务，hash方法改变时候，可能需要进行数据迁移； 这里需要注意的是，通过水平拆分来扩充系统性能，与主从同步读写分离来扩充数据库性能的方式有本质的不同。 通过水平拆分扩展数据库性能： （1）每个服务器上存储的数据量是总量的1/n，所以单机的性能也会有提升； （2）n个服务器上的数据没有交集，那个服务器上数据的并集是数据的全集； （3）数据水平拆分到了n个服务器上，理论上读性能扩充了n倍，写性能也扩充了n倍（其实远不止n倍，因为单机的数据量变为了原来的1/n）； 通过主从同步读写分离扩展数据库性能： （1）每个服务器上存储的数据量是和总量相同； （2）n个服务器上的数据都一样，都是全集； （3）理论上读性能扩充了n倍，写仍然是单点，写性能不变； 缓存层的水平拆分和数据库层的水平拆分类似，也是以范围拆分和哈希拆分的方式居多，就不再展开。","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"聚簇和非聚簇索引","slug":"聚簇和非聚簇索引","date":"2020-07-25T16:00:00.000Z","updated":"2020-08-05T08:44:06.554Z","comments":true,"path":"2020/07/26/聚簇和非聚簇索引/","link":"","permalink":"https://zhoulei.icu/2020/07/26/聚簇和非聚簇索引/","excerpt":"","text":"表结构文件：*.frm 在MYSQL中建立任何一张数据表，在其数据存放目录对应的数据库目录下都有对应表的.frm文件, .frm文件是用来保存每个数据表的元数据(meta)信息，包括表结构的定义等， 在mysql数据库中，myisam引擎和innodb引擎使用的索引类型不同，myisam对应的是非聚簇索引，而innodb对应的是聚簇索引。聚簇索引也叫复合索引、聚集索引等等。 非聚簇索引 ​ 以myisam为例，一个数据表table中，它是有table.frm(表结构以及定义)、table.myd（数据信息）以及table.myi（索引的数据）组成。table.myd记录了数据，table.myi记录了索引的数据。在用到索引时，先到table.myi（索引树）中进行查找，取到数据所在table.myd的行位置，拿到数据。所以myisam引擎的索引文件和数据文件是独立分开的，则称之为非聚簇索引。 myisam类型的索引，指向数据在行的位置。即每个索引相对独立，查询用到索引时，索引指向数据的位置。 聚簇索引 （两个文件） B+tree的数据存在叶子节点 ​ 以innodb为例，在一个数据table中，它的数据文件和索引文件是同一个文件。即在查询过程中，找到了索引，便找到了数据文件。在innodb中，即存储主键索引值，又存储行数据，称之为聚簇索引。 ​ innodb索引，指向主键对数据的引用。非主键索引则指向对主键的引用。innodb中，没有主见索引，则会使用unique索引，没有unique索引，则会使用数据库内部的一个行的id来当作主键索引。 ​ 在聚簇索引中，数据会被按照顺序整理排列，当使用where进行顺序、范围、大小检索时，会大大加速检索效率。 mysql执行的一般顺序？ 连接器 长链接和短链接长连接和短连接数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。建立连接的过程通常是比较复杂的，建议在使用中要尽量减少建立连接的动作，尽量使用长连接。但是全部使用长连接后，有时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。怎么解决这个问题呢？可以考虑以下两种方案：定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。MySQL 5.7 以上版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。 查询缓存 在建立连接后，就开始执行 select 语句了，执行前首先会查询缓存。MySQL 拿到查询请求后，会先查询缓存，看是不是执行过这条语句。执行过的语句及其结果会以 key-value 对的形式保存在一定的内存区域中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个value 就会被直接返回给客户端。如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，会提升效率。但是查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。对于更新压力大的数据库来说，查询缓存的命中率会非常低。如果业务中需要有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。MySQL 提供了这种按需使用的方式。可以将参数 query_cache_type 设置成 DEMAND，对于默认的 SQL 语句都将不使用查询缓存。而对于你确定要使用查询缓存的语句，可以SQL_CACHE 显式指定 select SQL_CACHE * from user where id=1 mysql 8.0取消缓存查找 分析器 如果查询缓存未命中，就要开始执行语句了。首先，MySQL 需要对 SQL 语句进行解析。分析器先会做词法分析。SQL 语句是由多个字符串和空格组成的，MySQL 需要识别出里面的字符串分别是什么，代表什么。MySQL 从你输入的 select 这个关键字识别出来，这是查询语句。它也要把字符串 user_info 识别成表名，把字符串 id 识别成列名。之后就要做语法分析。根据词法分析的结果，语法分析器会根据语法规则，判断输入的 SQL 语句是否满足 MySQL 语法。select * form user如果你 SQL 语句不对，就会收到 You have an error in your SQL syntax 的错误提醒，比如下面这个语句 from 写成了 form。 优化器 经过分析器的词法分析和语法分析后，还要经过优化器的处理。优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join：SELECT * FROM order_master JOIN order_detail USING (order_id) WHERE order_master.pay_status = 0 AND order_detail.detail_id = 1558963262141624521; 既可以先从表 order_master 里面取出 pay_status = 0 的记录的 order_id 值，再根据 order_id 值关联到表 order_detail，再判断 order_detail 里面 detail_id 的值是否等于 1558963262141624521。也可以先从表 order_detail 里面取出 detail_id = 1558963262141624521 的记录的 order_id 值，再根据 order_id 值关联到 order_master，再判断 order_master 里面 pay_status 的值是否等于 0。这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段 执行器 MySQL 通过分析器知道了要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。开始执行的时候，要先判断一下你对这个表 user_info 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"},{"name":"mysql","slug":"mysql","permalink":"https://zhoulei.icu/tags/mysql/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"mysql的锁","slug":"mysql锁","date":"2020-07-25T16:00:00.000Z","updated":"2020-08-05T08:28:02.104Z","comments":true,"path":"2020/07/26/mysql锁/","link":"","permalink":"https://zhoulei.icu/2020/07/26/mysql锁/","excerpt":"","text":"mysql的锁问题1 ： 如何查看mysql的自动提交的设置？select @@autocommit;查看默认提交的状态是否是自动提交0手动提交 1 自动提交 问题2 ：怎么设置autocommit;set @@autocommit=0; 设置的是本次mysql 窗口的自动提交取消，不影响别的连接的自动提交查看怎么锁定了行锁的例子的演示1 开启事务 未提交；2 重新打开一个连接，更新锁定的行的内容 ，一直等待释放锁3 第一个连接提交完，释放锁4 第二次的跟新获得锁得以提交5 如果长时间未获得锁，返回的错误超时 排它锁：又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。排它锁，也称作独占锁，一个锁在某一时刻只能被一个线程占有，其它线程必须等待锁被释放之后才可能获取到锁。又称：x锁, w 锁例子： 共享锁又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。 共享锁就是允许多个线程同时获取一个锁，一个锁可以同时被多个线程拥有。又称为：s锁, r锁 例子： 锁的粒度表锁： mysql 中最基本的锁策略，并且是开销最小的策略，锁定整张表，阻塞其他用户对该表的读取和写入，只有在没有写锁的时候在能获取读锁，读锁之间不阻塞。行锁： 最大程度支持了并发 ，但是这个方式也极大增加了锁的开销。(必须看mvcc和mvc和mvt) 死锁死锁的定义是指两个或者两个以上的事务，再同一资源上的相互占用，并请求对方锁定占用的资源，从而造成的恶性循环。造成死锁的原因：1 事务的执行顺序，这个很难避免。2 有些是数据引擎的实现方式引起的。 如何解决： 1 数据库检测死锁和死锁超时机制 例如innodb 检测到死锁会返回一个错误。2 就是事务等待时间设置超时，自动放弃锁的请求，这种不太友好3 innodb 将死锁中获取锁定最小的事务进行回滚。（锁定回滚法）","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"},{"name":"mysql","slug":"mysql","permalink":"https://zhoulei.icu/tags/mysql/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"mysql的一般优化","slug":"mysql的一般优化","date":"2020-07-24T16:00:00.000Z","updated":"2020-08-05T08:26:21.652Z","comments":true,"path":"2020/07/25/mysql的一般优化/","link":"","permalink":"https://zhoulei.icu/2020/07/25/mysql的一般优化/","excerpt":"","text":"mysql 的优化？优化数据的访问？ 确认应用程序是否检索了大量超过需要的数据。通常意味访问了太多的行，或者访问了太多的列 确认mysql服务器层是否存在分析大量超过需要的数据行。 水平分割()，垂直分割(前期太憨，没有业务分离，导致字段过多)，mysql主从（主库权限（可读，可写），从库（可读不可写））,集群（保证从主的切换，保证mysql的稳定性）， 索引（几个索引， alter ,create index），引擎的选择(innodb, myisam)，分区，分库(根据不同业务，不同需求的，)，字段设计（设计的好，我们就不分割），sql 语句的优化（*的选择， 索引的使用， 怎么查看索引（explain）,分页（条数的限制）) 是否向数据库请求了不需要的数据？ 有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃掉，这会给mysql服务器带来额外的负担，并增加网络开销，另外也会消耗应用服务器的cpu和内存资源。 case: 查询不需要的记录 比如我们要取出我们在网站上取出100条，我们只要其中的10条，这个时候怎么做呢？ select * from table 这个时候是不是一个全表的扫描，我们这个时候是不是获取了所有的，但是我们只要其中的几条 例如一个分页： 那这个时候我们是不是可以这样操作？ select * from table limit 0,10 除此之外还有什么优化的呢？ 比如 我们是不是可以根据自己所需要的字段来挑选呢？ 我们跟前端沟通需要展示的字段。 例如简单的多表的集联。 select * from table as A left join table as B on A.id=B.id limit 0,10 总是取出全部的列，每次看到select 的时候我们都需要用怀疑的眼光，是否是所有的列，取出全部列，会让优化器无法完成索引覆盖扫描这类优化，并且还会为服务器带来额外的I/o，内存和cpu的消耗。另外，公司的DBA是严禁写select 的语法的 select A.name,B.name from table as A left join table as B on A.id=B.id limit 0,10 重复查询相同的数据： 例如我们经常访问一些相同的数据，我们可以做一些缓存的操作，不必每次都去库里查询。 索引种类 普通索引：仅加速查询 唯一索引：加速查询 + 列值唯一（可以有null）只有一个 主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个 组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并 全文索引：对文本的内容进行分词，进行搜索 在公司新的需求出现的时候： 如果需要在线上数据库操作（数据库或者数据表的备份），1 数据量用户访问量最少的时候，2（备份）3 .操作数据表，4，出现问题，将备份的书数据import 数据库，数据恢复（） 索引有其明显的优势，也有其不可避免的缺点。 优点 索引的优点如下： 通过创建唯一索引可以保证数据库表中每一行数据的唯一性。 可以给所有的 MySQL 列类型设置索引。 可以大大加快数据的查询速度，这是使用索引最主要的原因。 在实现数据的参考完整性方面可以加速表与表之间的连接。 在使用分组和排序子句进行数据查询时也可以显著减少查询中分组和排序的时间 缺点 增加索引也有许多不利的方面，主要如下： 创建和维护索引组要耗费时间，并且随着数据量的增加所耗费的时间也会增加。 索引需要占磁盘空间，除了数据表占数据空间以外，每一个索引还要占一定的物理空间。 如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸。当对表中的数据进行增加、删除和修改的时候，索引也要动态维护，这样就降低了数据的维护速度 。 mysql 是否存在扫描额外的记录 最简单的衡量指标 响应时间 指的是 服务时间+ 排队时间 服务时间是指真正的花了时间，排队时间是指等待I/o操作完成，也可能等待锁的释放 扫描的行数和返回的行数 是否可以走索引，检测扫描行数的一致 重构查询的方式 一个复杂查询还是多个简单查询","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"},{"name":"mysql","slug":"mysql","permalink":"https://zhoulei.icu/tags/mysql/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"mysql 的引擎和事务","slug":"mysql 的引擎和事务","date":"2020-07-22T16:00:00.000Z","updated":"2020-08-05T08:24:03.271Z","comments":true,"path":"2020/07/23/mysql 的引擎和事务/","link":"","permalink":"https://zhoulei.icu/2020/07/23/mysql 的引擎和事务/","excerpt":"","text":"mysql 数据表引擎有哪些？ MyISAM、InnoDB、HEAP、BOB,ARCHIVE,CSV等。 MyISAM：成熟、稳定、易于管理，快速读取。一些功能不支持（事务等），表级锁。 InnoDB：支持事务、外键等特性、数据行锁定。空间占用大，不支持全文索引等（5.6.4以后支持全文索引）。 常用的两种引擎是： MyISAM和InnoDB Mysql 的存储引擎,myisam和innodb的区别？ MyISAM 是非事务的存储引擎，适合用于频繁查询的应用。表锁，不会出现死锁，适合小数据，小并发。 innodb是支持事务的存储引擎，合于插入和更新操作比较多的应用，设计合理的话是行锁（最大区别就在锁的级别上），适合大数据，大并发。(mvcc挖个坑) mysql的事务MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！ 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。 事务用来管理 insert,update,delete 语句 一般来说，事务是必须满足4个条件（ACID）：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。 事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 事务的隔离级别 Read uncommitted 读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。 Read committed 读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。 Repeatable read 重复读，就是在开始读取数据（事务开启）时，不再允许修改操作事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。 Serializable 序列化 Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。什么时候会出现幻读？事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。序列化解决幻读。 mysql执行的一般顺序？ 连接器 长链接和短链接长连接和短连接数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。建立连接的过程通常是比较复杂的，建议在使用中要尽量减少建立连接的动作，尽量使用长连接。但是全部使用长连接后，有时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。 show variables like ‘%max_connections%’ 查看最大连接数 ​ show processlist 查看当前连接数 ​ 怎么解决这个问题呢？可以考虑以下两种方案： ​ 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。MySQL 5.7 以上版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。 查询缓存 在建立连接后，就开始执行 select 语句了，执行前首先会查询缓存。MySQL 拿到查询请求后，会先查询缓存，看是不是执行过这条语句。执行过的语句及其结果会以 key-value 对的形式保存在一定的内存区域中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个value 就会被直接返回给客户端。如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，会提升效率。但是查询缓存的失效非常频繁，5，这个表上所有的查询缓存都会被清空。对于更新压力大的数据库来说，查询缓存的命中率会非常低。如果业务中需要有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。MySQL 提供了这种按需使用的方式。可以将参数 query_cache_type 设置成 DEMAND，对于默认的 SQL 语句都将不使用查询缓存。而对于你确定要使用查询缓存的语句，可以SQL_CACHE 显式指定 select SQL_CACHE * from user where id=1 mysql 8.0取消缓存查找 分析器 如果查询缓存未命中，就要开始执行语句了。首先，MySQL 需要对 SQL 语句进行解析。分析器先会做词法分析。SQL 语句是由多个字符串和空格组成的，MySQL 需要识别出里面的字符串分别是什么，代表什么。MySQL 从你输入的 select 这个关键字识别出来，这是查询语句。它也要把字符串 user_info 识别成表名，把字符串 id 识别成列名。之后就要做语法分析。根据词法分析的结果，语法分析器会根据语法规则，判断输入的 SQL 语句是否满足 MySQL 语法。 select name form user 如果你 SQL 语句不对，就会收到 You have an error in your SQL syntax 的错误提醒，比如下面这个语句 from 写成了 form。 优化器 经过分析器的词法分析和语法分析后，还要经过优化器的处理。优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join： SELECT * FROM order_master JOIN order_detail USING (order_id) WHERE order_master.pay_status = 0 AND order_detail.detail_id = 1558963262141624521; 既可以先从表 order_master 里面取出 pay_status = 0 的记录的 order_id 值，再根据 order_id 值关联到表 order_detail，再判断 order_detail 里面 detail_id 的值是否等于 1558963262141624521。也可以先从表 order_detail 里面取出 detail_id = 1558963262141624521 的记录的 order_id 值，再根据 order_id 值关联到 order_master，再判断 order_master 里面 pay_status 的值是否等于 0。这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段 执行器 MySQL 通过分析器知道了要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。开始执行的时候，要先判断一下你对这个表 user_info 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。 查询时间 = 等待时间是（wait_time）+ 真正的执行时间（query_time）。 ####","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"},{"name":"mysql","slug":"mysql","permalink":"https://zhoulei.icu/tags/mysql/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"Jwt+celery","slug":"Jwt+celery","date":"2020-07-21T16:00:00.000Z","updated":"2020-08-05T08:22:58.386Z","comments":true,"path":"2020/07/22/Jwt+celery/","link":"","permalink":"https://zhoulei.icu/2020/07/22/Jwt+celery/","excerpt":"","text":"celery+redisCelery 三部分 （消息中间件，worker(工人)， 存储单元） 消息中间件的任务：任务的一个分发 ———————&gt;worker (celery) ————————&gt;任务的执行和结果 celery的启动命令 celery -A message worker -l info pip install celery Pip install redis 建立任务需要 # coding: utf-8 from celery import Celery broker = &#39;redis://127.0.0.1:6379/0&#39; backend = &#39;redis://127.0.0.1:6379/0&#39; app = Celery(&#39;tasks&#39;, broker=broker, backend=backend) @app.task def add(x, y): return x+y @app.task() def add_1(x,y): return x*y jwtPayload ={} payload = { &quot;iss&quot;: &quot;gusibi.com&quot;, &quot;iat&quot;: int(time.time()), &quot;exp&quot;: int(time.time())+ 86400*7, &quot;aud&quot;: &quot;nishidashazi&quot;, 谁颁发的 &quot;username&quot;: &#39;xiaoming&#39;, 用户名字 &quot;uid&quot;: 32131, 用户的唯一表示 &quot;scopes&quot;: [&#39;open&#39;]， 那个平台认可 } token = jwt.encode(payload, &#39;secret&#39;, algorithm=&#39;HS256&#39;) 加密 Payload 主体， 加盐 (salt) 加密的方式 payload = jwt.decode(token, &#39;secret&#39;, audience=&#39;nishidashazi&#39;, algorithms=[&#39;HS256&#39;]) 解密 私钥（salt） audience 谁give的， algorithms 加密的方式 也可参考这篇文章https://www.jianshu.com/p/61e573611a06?tdsourcetag=s_pcqq_aiomsg","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"django","slug":"django","permalink":"https://zhoulei.icu/tags/django/"},{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"B-tree，B+tree","slug":"B-tree，B+tree","date":"2020-07-20T16:00:00.000Z","updated":"2020-08-05T08:16:13.099Z","comments":true,"path":"2020/07/21/B-tree，B+tree/","link":"","permalink":"https://zhoulei.icu/2020/07/21/B-tree，B+tree/","excerpt":"","text":"B-树特征： 根结点至少有两个子女。 每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m 每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m 所有的叶子结点都位于同一层。 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划 相比于二叉树做了事情？（为什么不用二叉树） 二叉树的高度和深度比较多，所以每次的io 会比较多，性能比较差，最次的情况会到达叶子结点 b-tree 我门相比于二叉树会低很多，我们最多的操作只是跟内存做了几次交互，性能提升，内存的操作和磁盘的io操作数量级不在一个等级上 由上看出： B-tree 将二叉树由一个“高瘦”的形象，变成了一个“矮胖”的形象。 B+树的特征： 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。 B+树的优势： 单一节点存储更多的元素，使得查询的IO次数更少。 所有查询都要查找到叶子节点，查询性能稳定。 所有叶子节点形成有序链表，便于范围查询。 参考链接https://mp.weixin.qq.com/s/jRZMMONW3QP43dsDKIV9VQ","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"websoket的优缺点及使用场景","slug":"websoket的优缺点及使用场景","date":"2020-07-19T16:00:00.000Z","updated":"2020-08-05T08:24:53.035Z","comments":true,"path":"2020/07/20/websoket的优缺点及使用场景/","link":"","permalink":"https://zhoulei.icu/2020/07/20/websoket的优缺点及使用场景/","excerpt":"","text":"WebsocketWebSocket是HTML5新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。 为什么传统的HTTP协议不能做到WebSocket实现的功能？这是因为HTTP协议是一个请求－响应协议，请求必须先由浏览器发给服务器，服务器才能响应这个请求，再把数据发送给浏览器。换句话说，浏览器不主动请求，服务器是没法主动发数据给浏览器的。 这样一来，要在浏览器中搞一个实时聊天，在线炒股（不鼓励），或者在线多人游戏的话就没法实现了，只能借助Flash这些插件。 也有人说，HTTP协议其实也能实现啊，比如用轮询或者Comet。轮询是指浏览器通过JavaScript启动一个定时器，然后以固定的间隔给服务器发请求，询问服务器有没有新消息。这个机制的缺点一是实时性不够，二是频繁的请求会给服务器带来极大的压力。 Comet本质上也是轮询，但是在没有消息的情况下，服务器先拖一段时间，等到有消息了再回复。这个机制暂时地解决了实时性问题，但是它带来了新的问题：以多线程模式运行的服务器会让大部分线程大部分时间都处于挂起状态，极大地浪费服务器资源。另外，一个HTTP连接在长时间没有数据传输的情况下，链路上的任何一个网关都可能关闭这个连接，而网关是我们不可控的，这就要求Comet连接必须定期发一些ping数据表示连接“正常工作”。 以上两种机制都治标不治本，所以，HTML5推出了WebSocket标准，让浏览器和服务器之间可以建立无限制的全双工通信，任何一方都可以主动发消息给对方。 WebSocket协议WebSocket并不是全新的协议，而是利用了HTTP协议来建立连接。我们来看看WebSocket连接是如何创建的。 首先，WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求，格式如下： GET ws://localhost:3000/ws/chat HTTP/1.1 Host: localhost Upgrade: websocket Connection: Upgrade Origin: http://localhost:3000 Sec-WebSocket-Key: client-random-string Sec-WebSocket-Version: 13 该请求和普通的HTTP请求有几点不同： GET请求的地址不是类似/path/，而是以ws://开头的地址； 请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接； Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据； Sec-WebSocket-Version指定了WebSocket的协议版本。 随后，服务器如果接受该请求，就会返回如下响应： HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: server-random-string 该响应代码101表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议。 版本号和子协议规定了双方能理解的数据格式，以及是否支持压缩等等。如果仅使用WebSocket的API，就不需要关心这些。 现在，一个WebSocket连接就建立成功，浏览器和服务器就可以随时主动发送消息给对方。消息有两种，一种是文本，一种是二进制数据。通常，我们可以发送JSON格式的文本，这样，在浏览器处理起来就十分容易。 为什么WebSocket连接可以实现全双工通信而HTTP连接不行呢？实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP协议的请求－应答机制限制了全双工通信。WebSocket连接建立以后，其实只是简单规定了一下：接下来，咱们通信就不使用HTTP协议了，直接互相发数据吧。 安全的WebSocket连接机制和HTTPS类似。首先，浏览器用wss://xxx创建WebSocket连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL/TLS协议。 浏览器很显然，要支持WebSocket通信，浏览器得支持这个协议，这样才能发出ws://xxx的请求。目前，支持WebSocket的主流浏览器如下： Chorme Firefox IE &gt;= 10 Sarafi &gt;= 6 Android &gt;= 4.4 iOS &gt;= 8 服务器由于WebSocket是一个协议，服务器具体怎么实现，取决于所用编程语言和框架本身。Node.js本身支持的协议包括TCP协议和HTTP协议，要支持WebSocket协议，需要对Node.js提供的HTTPServer做额外的开发。已经有若干基于Node.js的稳定可靠的WebSocket实现，我们直接用npm安装使用即可。","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"Redis-分布式锁","slug":"Redis-分布式锁","date":"2020-07-18T16:00:00.000Z","updated":"2020-08-05T07:50:53.853Z","comments":true,"path":"2020/07/19/Redis-分布式锁/","link":"","permalink":"https://zhoulei.icu/2020/07/19/Redis-分布式锁/","excerpt":"","text":"redis分布式锁什么是分布式锁？​ 分布式锁是控制分布式系统之间同步访问共享资源的一种方式。 什么实用分布式锁？​ 为了保证共享资源的数据一致性。 什么场景下使用分布式锁？​ 数据重要且要保证一致性 setnx指令（redis的分布式锁） 1、分布式锁 1. 分布式锁本质是占一个坑，当别的进程也要来占坑时发现已经被占，就会放弃或者稍后重试 2. 占坑一般使用 setnx(set if not exists)指令，只允许一个客户端占坑 3. 先来先占，用完了在调用del指令释放坑 &gt; setnx lock:codehole true .... do something critical .... &gt; del lock:codehole 4. 但是这样有一个问题，如果逻辑执行到中间出现异常，可能导致del指令没有被调用，这样就会陷入死锁，锁永远无法释放 5. 为了解决死锁问题，我们拿到锁时可以加上一个expire过期时间，这样即使出现异常，当到达过期时间也会自动释放锁 &gt; setnx lock:codehole true &gt; expire lock:codehole 5 .... do something critical .... &gt; del lock:codehole 6. 这样又有一个问题，setnx和expire是两条指令而不是原子指令，如果两条指令之间进程挂掉依然会出现死锁 7. 为了治理上面乱象，在redis 2.8中加入了set指令的扩展参数，使setnx和expire指令可以一起执行 &gt; set lock:codehole true ex 5 nx &#39;&#39;&#39; do something &#39;&#39;&#39; &gt; del lock:codehole ### 使用reids的 watch + multi + setnx 指令实现分布式锁 1）为什么要自己构建锁 然有类似的 SETNX 命令可以实现 Redis 中的锁的功能，但他锁提供的机制并不完整 . 并且setnx也不具备分布式锁的一些高级特性，还是得通过我们手动构建 2）创建一个redis锁 在 Redis 中，可以通过使用 SETNX 命令来构建锁：rs.setnx(lock_name, uuid值) . 而锁要做的事情就是将一个随机生成的 128 位 UUID 设置位键的值，防止该锁被其他进程获取 3）释放锁 锁的删除操作很简单，只需要将对应锁的 key 值获取到的 uuid 结果进行判断验证 . 符合条件（判断uuid值）通过 delete 在 redis 中删除即可，pipe.delete(lockname) 3. 此外当其他用户持有同名锁时，由于 uuid 的不同，经过验证后不会错误释放掉别人的锁 4）解决锁无法释放问题 1. 在之前的锁中，还出现这样的问题，比如某个进程持有锁之后突然程序崩溃，那么会导致锁无法释放 2. 而其他进程无法持有锁继续工作，为了解决这样的问题，可以在获取锁的时候加上锁的超时功能 import redis import uuid import time # 1.初始化连接函数 def get_conn(host=&quot;127.0.0.1&quot;,port=6379): rs = redis.Redis(host=host, port=port) return rs # 2. 构建redis锁 def acquire_lock(rs, lock_name, expire_time=10): &#39;&#39;&#39; rs: 连接对象 lock_name: 锁标识 acquire_time: 过期超时时间 return -&gt; False 获锁失败 or True 获锁成功 &#39;&#39;&#39; identifier = str(uuid.uuid4()) end = time.time() + expire_time while time.time() &lt; end: # 当获取锁的行为超过有效时间，则退出循环，本次取锁失败，返回False if rs.setnx(lock_name, identifier): # 尝试取得锁 return identifier # time.sleep(.001) return False # 3. 释放锁 def release_lock(rs, lockname, identifier): &#39;&#39;&#39; rs: 连接对象 lockname: 锁标识 identifier: 锁的value值，用来校验 &#39;&#39;&#39; if rs.get(lockname).decode() == identifier: # 防止其他进程同名锁被误删 rs.delete(lockname) return True # 删除锁 else: return False # 删除失败 #有过期时间的锁 def acquire_expire_lock(rs, lock_name, expire_time=10, locked_time=10): &#39;&#39;&#39; rs: 连接对象 lock_name: 锁标识 acquire_time: 过期超时时间 locked_time: 锁的有效时间 return -&gt; False 获锁失败 or True 获锁成功 &#39;&#39;&#39; identifier = str(uuid.uuid4()) end = time.time() + expire_time while time.time() &lt; end: # 当获取锁的行为超过有效时间，则退出循环，本次取锁失败，返回False if rs.setnx(lock_name, identifier): # 尝试取得锁 # print(&#39;锁已设置: %s&#39; % identifier) rs.expire(lock_name, locked_time) return identifier time.sleep(.001) return False &#39;&#39;&#39;在业务函数中使用上面的锁&#39;&#39;&#39; def sale(rs): start = time.time() # 程序启动时间 with rs.pipeline() as p: &#39;&#39;&#39; 通过管道方式进行连接 多条命令执行结束，一次性获取结果 &#39;&#39;&#39; while 1: lock = acquire_lock(rs, &#39;lock&#39;) if not lock: # 持锁失败 continue #开始监测&quot;lock&quot; p.watch(&quot;lock&quot;) try: #开启事务 p.multi() count = int(rs.get(&#39;apple&#39;)) # 取量 p.set(&#39;apple&#39;, count-1) # 减量 # time.sleep(5) #提交事务 p.execute() print(&#39;当前库存量: %s&#39; % count) #成功则跳出循环 break except: #事务失败对应处理 print(&quot;修改数据失败&quot;) #无论成功与否最终都需要释放锁 finally: res = release_lock(rs, &#39;lock&#39;, lock) #释放锁成功， if res: print(&quot;删除锁成功&quot;) #释放锁失败，强制删除 else: print(&quot;删除锁失败,强制删除锁&quot;) res = rs.delete(&#39;lock&#39;) print(res) print(&#39;[time]: %.2f&#39; % (time.time() - start)) rs = redis.Redis(host=&#39;127.0.0.1&#39;, port=6379) # 连接redis # rs.set(&#39;apple&#39;,1000) # # 首先在redis中设置某商品apple 对应数量value值为1000 sale(rs) 优化锁无法释放的问题，为锁添加过期时间 def acquire_expire_lock(rs, lock_name, expire_time=10, locked_time=10): &#39;&#39;&#39; rs: 连接对象 lock_name: 锁标识 acquire_time: 过期超时时间 locked_time: 锁的有效时间 return -&gt; False 获锁失败 or True 获锁成功 &#39;&#39;&#39; identifier = str(uuid.uuid4()) end = time.time() + expire_time while time.time() &lt; end: # 当获取锁的行为超过有效时间，则退出循环，本次取锁失败，返回False if rs.setnx(lock_name, identifier): # 尝试取得锁 # print(&#39;锁已设置: %s&#39; % identifier) rs.expire(lock_name, locked_time) return identifier time.sleep(.001) return False 关于分布式锁Watch：监测一个key。如果这个key的value改变，那个接下来的事务操作全部失效 multi: 开启一个事务。 Setnx: 跟set一样都往redis添加一个key。不一定的地方在于：set的时候如果这个值存在，就是修改操作。不存在就是添加操作。setnx：存在的时候不能再次添加，不存在的时候才能添加。","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"},{"name":"redis","slug":"redis","permalink":"https://zhoulei.icu/tags/redis/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"Redis命令以及关于事务操作","slug":"redis命令","date":"2020-07-17T16:00:00.000Z","updated":"2020-08-05T07:47:05.426Z","comments":true,"path":"2020/07/18/redis命令/","link":"","permalink":"https://zhoulei.icu/2020/07/18/redis命令/","excerpt":"","text":"keys * 展示有数据的key multi开启事务 incr ：key+1 127.0.0.1:6379&gt; multi OK 127.0.0.1:6379&gt; set price 10 QUEUED 127.0.0.1:6379&gt; incr price QUEUED 127.0.0.1:6379&gt; get price QUEUED 127.0.0.1:6379&gt; exec 1) OK 2) (integer) 11 3) &quot;11&quot; decr：key-1 127.0.0.1:6379&gt; multi OK 127.0.0.1:6379&gt; decr price QUEUED 127.0.0.1:6379&gt; get price QUEUED 127.0.0.1:6379&gt; exec 1) (integer) 10 2) &quot;10&quot; 在redis事务中，命令错， 全部不执行； 127.0.0.1:6379&gt; multi OK 127.0.0.1:6379&gt; set name2 python QUEUED 127.0.0.1:6379&gt; set name3 java QUEUED 127.0.0.1:6379&gt; set name4 ruby QUEUED 127.0.0.1:6379&gt; set name5 golang QUEUED 127.0.0.1:6379&gt; setget name2 (error) ERR unknown command &#39;setget&#39; 127.0.0.1:6379&gt; getset name2 (error) ERR wrong number of arguments for &#39;getset&#39; command 127.0.0.1:6379&gt; exec (error) EXECABORT Transaction discarded because of previous errors. 127.0.0.1:6379&gt; get name3 (nil) 语法错， 执行正确的。 127.0.0.1:6379&gt; multi OK 127.0.0.1:6379&gt; set name2 python QUEUED 127.0.0.1:6379&gt; set name3 java QUEUED 127.0.0.1:6379&gt; incr name3 QUEUED 127.0.0.1:6379&gt; get name3 QUEUED 127.0.0.1:6379&gt; exec 1) OK 2) OK 3) (error) ERR value is not an integer or out of range 4) &quot;java&quot; discard取消事务，放弃事务中的命令 127.0.0.1:6379&gt; multi OK 127.0.0.1:6379&gt; set money 100 QUEUED 127.0.0.1:6379&gt; set money2 200 QUEUED 127.0.0.1:6379&gt; discard OK 127.0.0.1:6379&gt; exec (error) ERR EXEC without MULTI decrby 指定减少数 watch 监控事务 on watch 取消监控","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"},{"name":"redis","slug":"redis","permalink":"https://zhoulei.icu/tags/redis/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"Flask-Restful","slug":"Flask-Restful","date":"2020-07-15T16:00:00.000Z","updated":"2020-08-05T07:34:13.033Z","comments":true,"path":"2020/07/16/Flask-Restful/","link":"","permalink":"https://zhoulei.icu/2020/07/16/Flask-Restful/","excerpt":"","text":"Flask-Restful安装pip pip install flask pip install flask_restful pip install flask_cors 代码 from flask import Flask,request,jsonify,redirect from flask_restful import Api from flask_cors import CORS from flask_restful import Resource from flask import Response import json from flask import render_template app = Flask(__name__) app.config.from_pyfile(&#39;config.ini&#39;) CORS(app, supports_credentials=True) # 用于处理跨域问题 &#39;&#39;&#39;添加api资源&#39;&#39;&#39; api = Api(app) class HelloWorld(Resource): def get(self): data = json.dumps({&#39;hello&#39;:&#39;world&#39;}) resp = Response(response=data, status=200, mimetype=&quot;application/json&quot;) return resp #定义访问的路由 api.add_resource(HelloWorld, &#39;/api/index&#39;) if __name__ == &quot;__main__&quot;: app.run()","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"},{"name":"flask","slug":"flask","permalink":"https://zhoulei.icu/tags/flask/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"flask基础","slug":"Flask基础","date":"2020-07-14T16:00:00.000Z","updated":"2020-08-05T07:45:33.925Z","comments":true,"path":"2020/07/15/Flask基础/","link":"","permalink":"https://zhoulei.icu/2020/07/15/Flask基础/","excerpt":"","text":"什么是FlaskFlask是一个Python编写的Web微框架，让我们可以使用Python语言快速实现一个网站或Web服务。 Django和Flask有什么区别?flaskFlask自由、灵活，可扩展性强，第三方库的选择面广，开发时可以结合自己最喜欢用的轮子，也能结合最流行最强大的Python库入门简单，即便没有多少web开发经验，也能很快做出网站非常适用于小型网站非常适用于开发web服务的API开发大型网站无压力，但代码架构需要自己设计，开发成本取决于开发者的能力各方面性能均等于或优于DjangoDjango自带的或第三方的好评如潮的功能，Flask上总会找到与之类似第三方Flask灵活开发，Python高手基本都会喜欢Flask，但对Django却可能褒贬不Flask与关系型数据库的配合使用不弱于Django，而其与NoSQL数据库的配合远远优于Django djangoDjango太重了，除了web框架，自带ORM和模板引擎，灵活和自由度不够高Django能开发小应用，但总会有“杀鸡焉用牛刀”的感觉Django的自带ORM非常优秀，综合评价略高于SQLAlchemyDjango自带的模板引擎简单好用，但其强大程度和综合评价略低于Jinja2Django自带ORM也使Django与关系型数据库耦合度过高，如果想使用MongoDB等NoSQL数据，需要选取合适的第三方库，且总感觉Django+SQL才是天生一对的搭配，Django+NoSQL砍掉了Django的半壁江山Django目前支持Jinja等非官方模板引擎Django自带的数据库管理app好评如潮Django非常适合企业级网站的开发：快速、靠谱、稳定Django成熟、稳定、完善，但相比于Flask，Django的整体生态相对封闭Django是Python web框架的先驱，用户多，第三方库最丰富，最好的Python库，如果不能直接用到Django中，也一定能找到与之对应的移植Django上手也比较容易，开发文档详细、完善，相关资料丰富 安装当安装 Flask 时，以下配套软件会被自动安装。 Werkzeug 用于实现 WSGI ，应用和服务之间的标准 Python 接口。 Jinja 用于渲染页面的模板语言。 MarkupSafe 与 Jinja 共用，在渲染页面时用于避免不可信的输入，防止注入攻击。 ItsDangerous 保证数据完整性的安全标志数据，用于保护 Flask 的 session cookie. Click 是一个命令行应用的框架。用于提供 flask 命令，并允许添加自定义 管理命令。 小应用#代码案例 from flask import Flask app = Flask(__name__) #参数默认写为__name__ @app.route(&#39;/&#39;) #路由 def hello_world(): return &#39;Hello_World&#39; if __name__ == &quot;__main__&quot;: #写上这行可以直接运行该文件，不必在命令行敲命令 app.run() 启动命令 set FLASK_APP=hello.py flask run FLASK_APP 环境变量中储存的是模块的名称，运行 flask run 命令就 会导入这个模块。如果模块的名称不对，那么就会出现导入错误。出现错误的时机是在 应用开始的时候。如果调试模式打开的情况下，会在运行到应用开始的时候出现导入 错误。出错信息会告诉你尝试导入哪个模块时出错，为什么会出错。 最常见的错误是因为拼写错误而没有真正创建一个 app 对象。 关于配置初始化参数 import_name Flask程序所在的包(模块)，传 __name__ 就可以 其可以决定 Flask 在访问静态文件时查找的路径 static_path 静态文件访问路径(不推荐使用，使用 static_url_path 代替) static_url_path 静态文件访问路径，可以不传，默认为：/ + static_folder static_folder 静态文件存储的文件夹，可以不传，默认为 static template_folder 模板文件存储的文件夹，可以不传，默认为 templates 调试模式每次应用代码 修改之后都需要手动重启服务器，所以可以设置DEBUG（调试模式），可以实现： 程序代码修改后可以自动重启服务器 在服务器出现相关错误的时候可以直接将错误信息进行抛出到控制台打印 设置 Flask 配置有以下三种方式： 从配置对象中加载(常用) app.config.from_object() 从配置文件中加载 app.config.from_pyfile() 从环境变量中加载(了解) app.config.from_envvar() 配置对象# 配置对象，里面定义需要给 APP 添加的一系列配置 class Config(object): DEBUG = True # 创建 Flask 类的对象,指向程序所在的包的名称 app = Flask(__name__) # 从配置对象中加载配置 app.config.from_object(Config) 运行测试，在修改代码之后直接保存，会自动重启服务器 配置文件在该文件目录下新建config.ini 文件，并编辑内容为DEBUG = True 然后在hello.py中 # 创建 Flask 类的对象,指向程序所在的包的名称 app = Flask(__name__) # 从配置文件中加载配置 app.config.from_pyfile(&#39;config.ini&#39;) 直接写在app.run()中直接写入debug=True if __name__ == &quot;__main__&quot;: app.run(debug=True) app.run的参数可以指定运行的主机IP地址，端口，是否开启调试模式 app.run(host=&quot;0.0.0.0&quot;, port=5000, debug = True) 路由传参默认为srt类型 但是参数中不能带有/ @app.route(&#39;/&lt;username&gt;&#39;) def hello_world(username): return &#39;%s&#39; % username int类型 只接收int类型的参数 @app.route(&#39;/&lt;int:num&gt;&#39;) def hello_world(num): return &#39;%d&#39; % num path 类似字符串传参，但是参数中可以有/ @app.route(&#39;/&lt;path:abc&gt;&#39;) def hello_world(abc): return &#39;%s&#39; % abc 除此之外还有： float 接受正浮点数 uuid接受 UUID 字符串 若是传的参数不满足要求，则会报404 这里可以看出flask通过get方法传参数不需要指定变量名， 在`@app.route(‘/‘)` 这里已经定义好了，所以路由后边直接写/+值就可以，比如 http://127.0.0.1:5000/zhoulei 而如果是django的话则要写为 http://127.0.0.1:5000/?username=zhoulei 唯一的 URL / 重定向行为以下两条规则的不同之处在于是否使用尾部的斜杠 @app.route(&#39;/projects/&#39;) def projects(): return &#39;The project page&#39; @app.route(&#39;/about&#39;) def about(): return &#39;The about page&#39; projects 的 URL 是中规中矩的，尾部有一个斜杠，看起来就如同一个文件夹。 访问一个没有斜杠结尾的 URL 时 Flask 会自动进行重定向，帮你在尾部加上一个斜杠。 about 的 URL 没有尾部斜杠，因此其行为表现与一个文件类似。如果访问这个 URL 时添加了尾部斜杠就会得到一个 404 错误。这样可以保持 URL 唯一，并帮助 搜索引擎避免重复索引同一页面。 指定请求方式在 Flask 中，定义一个路由，默认的请求方式为： GET OPTIONS(自带) HEAD(自带) 如果想添加请求方试，那么可以如下指定： @app.route(&#39;/demo&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])1 def demo(): # 直接从请求中取到请求方式并返回 return request.method 渲染模板Flask 自动配置 Jinja2 模板引擎。 使用 render_template() 方法可以渲染模板，你只要提供模板名称和需要 作为参数传递给模板的变量就行了。下面是一个简单的模板渲染例子: from flask import render_template @app.route(&#39;/hello/&#39;) @app.route(&#39;/hello/&lt;name&gt;&#39;) def hello(name=None): return render_template(&#39;hello.html&#39;, name=name) Flask 会在 templates 文件夹内寻找模板。因此，如果你的应用是一个模块， 那么模板文件夹应该在模块旁边；如果是一个包，那么就应该在包里面： 情形 1 : 一个模块: /application.py /templates /hello.html 情形 2 : 一个包: /application /__init__.py /templates /hello.html 模板示例： &lt;!doctype html&gt; &lt;title&gt;Hello from Flask&lt;/title&gt; {% if name %} Hello {{ name }}! {% else %} Hello, World! {% endif %} 返回json# 返回JSON @app.route(&#39;/demo4&#39;) def demo4(): json_dict = { &quot;user_id&quot;: 10, &quot;user_name&quot;: &quot;zhoulei&quot; } return jsonify(json_dict) 使用 jsonify来返回json数据 结果 { &quot;user_id&quot;: 10, &quot;user_name&quot;: &quot;zhoulei&quot; } 解决中文乱码问题直接在代码中添加 app.config[‘JSON_AS_ASCII&#39;] = False 或者在config.ini中添加JSON_AS_ASCII = False 跳转(重定向)跳转到百度 # 重定向 @app.route(&#39;/demo5&#39;) def demo5(): return redirect(&#39;http://www.baidu.com&#39;) 视图函数之间跳转 @app.route(&#39;/demo1&#39;) def demo1(): return &#39;demo1&#39; # 重定向 @app.route(&#39;/demo5&#39;) def demo5(): return redirect(url_for(&#39;demo1&#39;)) 带参数跳转 # 路由传递参数 @app.route(&#39;/user/&lt;int:user_id&gt;&#39;) def user_info(user_id): return &#39;hello %d&#39; % user_id # 重定向 @app.route(&#39;/demo5&#39;) def demo5(): # 使用 url_for 生成指定视图函数所对应的 url return redirect(url_for(&#39;user_info&#39;, user_id=100)) flask SQLAlchemypip install flask-sqlalchemy 如果连接的是 mysql 数据库，需要安装 mysqldb pip install flask-mysqldb 在config.ini文件中配置 SQLALCHEMY_DATABASE_URI = &#39;mysql://root:123@127.0.0.1:3306/test&#39; root代表用户名，123表示自己mysql的密码，最后的test则是已经存在的数据库 在视图函数中定义模型类from flask import Flask from flask_sqlalchemy import SQLAlchemy app = Flask(__name__) db = SQLAlchemy(app) class Role(db.Model): # 定义列对象 id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) us = db.relationship(&#39;User&#39;, backref=&#39;role&#39;) class User(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True, index=True) email = db.Column(db.String(64),unique=True) password = db.Column(db.String(64)) role_id = db.Column(db.Integer, db.ForeignKey(&#39;role.id&#39;)) db.create_all() 创建表db.create_all() 删除表db.drop_all() 插入一条数据ro1 = Role(name=&#39;admin&#39;) db.session.add(ro1) db.session.commit() #再次插入一条数据 ro2 = Role(name=&#39;user&#39;) db.session.add(ro2) db.session.commit() 一次插入多条数据us1 = User(name=&#39;wang&#39;,email=&#39;wang@163.com&#39;,password=&#39;123456&#39;,role_id=ro1.id) us2 = User(name=&#39;zhang&#39;,email=&#39;zhang@189.com&#39;,password=&#39;201512&#39;,role_id=ro2.id) us3 = User(name=&#39;chen&#39;,email=&#39;chen@126.com&#39;,password=&#39;987654&#39;,role_id=ro2.id) us4 = User(name=&#39;zhou&#39;,email=&#39;zhou@163.com&#39;,password=&#39;456789&#39;,role_id=ro1.id) us5 = User(name=&#39;tang&#39;,email=&#39;tang@itheima.com&#39;,password=&#39;158104&#39;,role_id=ro2.id) us6 = User(name=&#39;wu&#39;,email=&#39;wu@gmail.com&#39;,password=&#39;5623514&#39;,role_id=ro2.id) us7 = User(name=&#39;qian&#39;,email=&#39;qian@gmail.com&#39;,password=&#39;1543567&#39;,role_id=ro1.id) us8 = User(name=&#39;liu&#39;,email=&#39;liu@itheima.com&#39;,password=&#39;867322&#39;,role_id=ro1.id) us9 = User(name=&#39;li&#39;,email=&#39;li@163.com&#39;,password=&#39;4526342&#39;,role_id=ro2.id) us10 = User(name=&#39;sun&#39;,email=&#39;sun@163.com&#39;,password=&#39;235523&#39;,role_id=ro2.id) db.session.add_all([us1,us2,us3,us4,us5,us6,us7,us8,us9,us10]) db.session.commit() 增删改查filter_by精确查询返回名字等于wang的所有人 User.query.filter_by(name=&#39;wang&#39;).all() first()返回查询到的第一个对象User.query.first() all()返回查询到的所有对象User.query.all() filter模糊查询，返回名字结尾字符为g的所有数据。User.query.filter(User.name.endswith(&#39;g&#39;)).all() get():参数为主键，如果主键不存在没有返回内容User.query.get() 逻辑非，返回名字不等于wang的所有数据User.query.filter(User.name!=&#39;wang&#39;).all() not_ 相当于取反from sqlalchemy import not_ User.query.filter(not_(User.name==&#39;chen&#39;)).all() 逻辑与，需要导入and，返回and()条件满足的所有数据from sqlalchemy import and_ User.query.filter(and_(User.name!=&#39;wang&#39;,User.email.endswith(&#39;163.com&#39;))).all() 逻辑或，需要导入or_from sqlalchemy import or_ User.query.filter(or_(User.name!=&#39;wang&#39;,User.email.endswith(&#39;163.com&#39;))).all() 查询数据后删除user = User.query.first() db.session.delete(user) db.session.commit() User.query.all() 更新数据user = User.query.first() user.name = &#39;dong&#39; db.session.commit() User.query.first() 关联查询示例： 角色和用户的关系是一对多的关系，一个角色可以有多个用户，一个用户只能属于一个角色。 查询角色的所有用户 #查询roles表id为1的角色 ro1 = Role.query.get(1) #查询该角色的所有用户 ro1.us.all() 查询用户所属角色 #查询users表id为3的用户 us1 = User.query.get(3) #查询用户属于什么角色 us1.role 数据库迁移安装 pip install flask-migrate 代码： from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_migrate import Migrate,MigrateCommand from flask_script import Shell,Manager app = Flask(__name__) manager = Manager(app) db = SQLAlchemy(app) #第一个参数是Flask的实例，第二个参数是Sqlalchemy数据库实例 migrate = Migrate(app,db) #manager是Flask-Script的实例，这条语句在flask-Script中添加一个db命令 manager.add_command(&#39;db&#39;,MigrateCommand) #模型类 class Role(db.Model): # 定义列对象 id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) us = db.relationship(&#39;User&#39;, backref=&#39;role&#39;) class User(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True, index=True) email = db.Column(db.String(64),unique=True) password = db.Column(db.String(64)) role_id = db.Column(db.Integer, db.ForeignKey(&#39;role.id&#39;)) if __name__ == &#39;__main__&#39;: manager.run() 创建迁移仓库#这个命令会创建migrations文件夹，所有迁移文件都放在里面。 python database.py db init #生成迁移文件 python database.py db migrate -m &#39;注释&#39; 更新数据库python database.py db upgrade 返回以前的版本可以根据history命令找到版本号,然后传给downgrade命令: python app.py db history 输出格式：&lt;base&gt; -&gt; 版本号 (head), initial migration 回滚到指定版本 python app.py db downgrade 版本号 蓝图创建一个蓝图对象from flask import Blueprint #此处的admin自定义，一般为所在文件的名称 admin=Blueprint(&#39;admin&#39;,__name__) 在主应用注册蓝图app.register_blueprint(admin,url_prefix=&#39;/admin&#39;) #最后的admin为访问蓝图中的视图的方式，也就是项目启动后，需要先写/admin，再写蓝图中的路由 勾子函数在客户端和服务器交互的过程中，有些准备工作或扫尾工作需要处理，比如： 在请求开始时，建立数据库连接； 在请求开始时，根据需求进行权限校验； 在请求结束时，指定数据的交互格式； 为了让每个视图函数避免编写重复功能的代码，Flask提供了通用设施的功能，即请求钩子。 请求钩子是通过装饰器的形式实现，Flask支持如下四种请求钩子： before_first_request 在处理第一个请求前执行 before_request 在每次请求前执行 如果在某修饰的函数中返回了一个响应，视图函数将不再被调用 after_request 如果没有抛出错误，在每次请求后执行 接受一个参数：视图函数作出的响应 在此函数中可以对响应值在返回之前做最后一步修改处理 需要将参数中的响应在此参数中进行返回 teardown_request： 在每次请求后执行 接受一个参数：错误信息，如果有相关错误抛出","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"},{"name":"flask","slug":"flask","permalink":"https://zhoulei.icu/tags/flask/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"python发送QQ邮件","slug":"python发送QQ邮件","date":"2020-07-11T16:00:00.000Z","updated":"2020-08-05T07:12:47.031Z","comments":true,"path":"2020/07/12/python发送QQ邮件/","link":"","permalink":"https://zhoulei.icu/2020/07/12/python发送QQ邮件/","excerpt":"","text":"第一步，登录QQ邮箱， 走到设置 开启pop3服务 和SMTP服务SMTP 服务相当于一个服务器 发送邮件使用SMTP服务器第二步 开启成功后，我们会拿到秘钥串 ，也就是相当于我们登录SMTP服务 我们就有了一个权限（发送邮件的权限）代码登录的时候我们输入自己的QQ邮箱，密码相当于秘钥串。第三步 代码完成 引入SMTPlib包（SMTP相关）和关于email操作的包 （发送邮件的相关）问题1 发送的是什么？ 邮件 ，邮件的内容当然由关于邮件部分的包或者模块来操作。 问题2 是谁来发送这个问题？ SMTP 服务器来发送 ，由SMTP相关的模块来构造。导包from email.mime.text import MIMEText import smtplib from email.mime.multipart import MIMEMultipart from email.mime.base import MIMEBase from email.header import Header from email import encoders from email.header import Header from email.utils import parseaddr, formataddr 发送纯文本格式邮件def _format_addr(s): name, addr = parseaddr(s) # 解析邮件地址，name为邮件人，addr为邮件地址 return formataddr((Header(name, &#39;utf-8&#39;).encode(), addr)) # 格式化邮件地址 from_addr = &#39;xxxx@qq.com&#39; #发送者邮箱 password = &#39;xxxx&#39; #输入密码,此密码为邮箱的授权码 to_addr = &#39;xxxx@qq.com&#39; #收件人地址 smtp_server = &#39;smtp.qq.com&#39; #SMTP服务器地址 #这里有三个参数，第一个参数为邮件正文，第二个参数为邮件类型，传入&#39;plain&#39;表示纯文本，第三个参数&#39;utf-8&#39;是编码，以保证兼容多语言 msg = MIMEText(&#39;hello,send by Python.....&#39;,&#39;plain&#39;,&#39;utf-8&#39;) msg[&#39;From&#39;] = _format_addr(&#39;学生 &lt;%s&gt;&#39; % from_addr) # 添加发件人 msg[&#39;To&#39;] = _format_addr(&#39;老师 &lt;%s&gt;&#39; % to_addr) # 添加收件人 msg[&#39;Subject&#39;] = Header(&#39;SMTP测试&#39;, &#39;utf-8&#39;).encode() # 添加邮件主题 server = smtplib.SMTP(smtp_server, 25) # SMTP协议默认端口是25 server.set_debuglevel(1) # 打印和SMTP服务器交互的所有信息 server.login(from_addr, password) # 登录SMTP服务器 server.sendmail(from_addr, [to_addr], msg.as_string()) #发邮件 server.quit() 发送HTML格式的邮件在构造MIMEText对象时，把HTML字符串传进去，再把第二个参数由plain变为html就可以了： #注意将第二个参数改为html msg = MIMEText(&#39;&lt;html&gt;&lt;h1&gt;你好！&lt;h1&gt;&lt;html&gt;&#39;,&#39;html&#39;,&#39;utf-8&#39;) 发送txt格式的邮件首先要创建MIMEMultipart()实例，然后构造附件，如果有多个附件，可依次构造，最后利用smtplib.smtp发送。 def _format_addr(s): name, addr = parseaddr(s) # 解析邮件地址，name为邮件人，addr为邮件地址 return formataddr((Header(name, &#39;utf-8&#39;).encode(), addr)) # 格式化邮件地址 from_addr = &#39;xxxx@qq.com&#39; #发送者邮箱 password = &#39;xxxx&#39; #输入密码,此密码为邮箱的授权码 to_addr = &#39;xxxx@qq.com&#39; #收件人地址 smtp_server = &#39;smtp.qq.com&#39; #SMTP服务器地址 #创建一个带附件的实例 msg = MIMEMultipart() #邮件正文内容 msg.attach(MIMEText(&#39;这是测试Python发送附件功能....&#39;,&#39;plain&#39;,&#39;utf-8&#39;)) msg[&#39;From&#39;] = _format_addr(&#39;学生 &lt;%s&gt;&#39; % from_addr) # 添加发件人 msg[&#39;To&#39;] = _format_addr(&#39;老师 &lt;%s&gt;&#39; % to_addr) # 添加收件人 msg[&#39;Subject&#39;] = Header(&#39;SMTP测试&#39;, &#39;utf-8&#39;).encode() # 添加邮件主题 #添加附件 mime = MIMEApplication(open(&#39;123.txt&#39;,&#39;rb&#39;).read()) mime.add_header(&#39;Content-Disposition&#39;, &#39;attachment&#39;, filename=&quot;123.txt&quot;) msg.attach(mime) server = smtplib.SMTP(smtp_server, 25) # SMTP协议默认端口是25 server.starttls() server.set_debuglevel(1) # 打印和SMTP服务器交互的所有信息 server.login(from_addr, password) # 登录SMTP服务器 server.sendmail(from_addr, [to_addr], msg.as_string()) #发邮件 server.quit() 发送图片附件#创建一个带附件的实例 msg = MIMEMultipart() msg.attach(MIMEText(&#39;这是测试Python发送附件功能....&#39;,&#39;plain&#39;,&#39;utf-8&#39;)) msg[&#39;From&#39;] = _format_addr(&#39;学生 &lt;%s&gt;&#39; % from_addr) # 添加发件人 msg[&#39;To&#39;] = _format_addr(&#39;老师 &lt;%s&gt;&#39; % to_addr) # 添加收件人 msg[&#39;Subject&#39;] = Header(&#39;SMTP测试&#39;, &#39;utf-8&#39;).encode() # 添加邮件主题 with open(&#39;123.jpg&#39;, &#39;rb&#39;) as f: # 打开需要添加的附件 # 创建MIMEBase对象，即附件内容 mime = MIMEBase(&#39;image&#39;, &#39;jpg&#39;, filename=&#39;123.jpg&#39;) # 添加必要的头文件 mime.add_header(&#39;Content-Disposition&#39;, &#39;attachment&#39;, filename=&#39;123.jpg&#39;) mime.add_header(&#39;Content-ID&#39;, &#39;&lt;0&gt;&#39;) mime.add_header(&#39;X-Attachment-ID&#39;, &#39;0&#39;) mime.set_payload(f.read()) # 读进附件的内容 encoders.encode_base64(mime) # 用base64编码 msg.attach(mime) 然后，按正常的邮件发送流程补充代码即可 若想在邮件正文中显示图片，需要先把图片作为附件，然后在HTML中通过引用src=”cid:0”就可以把附件作为图片嵌入了 msg.attach(MIMEText(&#39;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, my friend...&lt;/h1&gt;&#39; + &#39;&lt;p&gt;&lt;img src=&quot;cid:0&quot;&gt;&lt;/p&gt;&#39; + &#39;&lt;/body&gt;&lt;/html&gt;&#39;, &#39;html&#39;, &#39;utf-8&#39;)) 这个时候图片不再作为附件发送，而是直接在邮件正文中显示。 如果有多张图片，则給它们编号后，引用不同的cid:x即可。 同时发送纯文本和html格式通过创建MIMEMultipart对象，我们可以让邮件内容即支持plain，也支持HTML。 在创建MIMEMultipart时指定subtype是alternative： msg = MIMEMultipart(&#39;alternative&#39;) msg[&#39;From&#39;] = ... msg[&#39;To&#39;] = ... msg[&#39;Subject&#39;] = ... msg.attach(MIMEText(&#39;Hello, my friend...&#39;, &#39;plain&#39;, &#39;utf-8&#39;)) msg.attach(MIMEText(&#39;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, my friend...&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&#39;, &#39;html&#39;, &#39;utf-8&#39;)) 一旦收件人无法查看HTML格式的邮件，就会自动变为plain格式查看。 STMP加密使用标准的25端口连接SMTP服务器时，使用的是明文传输，在发送的过程有可能被窃听。 想要给邮件加密，添加starttls()方法即可： server = smtplib.SMTP(smtp_server, 25) server.starttls() 总结只要掌握了各种邮件类型的构造方法，正确设置好邮件头，就可以顺利发出。 构造一个邮件对象就是一个Messag对象，如果构造一个MIMEText对象，就表示一个文本邮件对象，如果构造一个MIMEImage对象，就表示一个作为附件的图片，要把多个对象组合起来，就用MIMEMultipart对象，而MIMEBase可以表示任何对象。它们的继承关系如下： Message +- MIMEBase +- MIMEMultipart +- MIMENonMultipart +- MIMEMessage +- MIMEText +- MIMEImage 可详细参考此文档：https://cloud.tencent.com/developer/article/1445126","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"},{"name":"python","slug":"python","permalink":"https://zhoulei.icu/tags/python/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"python数据类型方法","slug":"python的几个数据类型方法","date":"2020-07-10T16:00:00.000Z","updated":"2020-08-05T07:12:13.872Z","comments":true,"path":"2020/07/11/python的几个数据类型方法/","link":"","permalink":"https://zhoulei.icu/2020/07/11/python的几个数据类型方法/","excerpt":"","text":"字符串（1）字符串转换成列表 a = &quot;aaleade&quot; b = list(a) print(b) （2）列表转换成字符串 a = [11,22,33,&quot;alex&quot;] s = &quot;&quot; for L in a: s = s +str(L) print(s) （3）replace() 替换 a = &quot;alex&quot; print(a.replace(&quot;l&quot;,&quot;aaa&quot;)) （4）find() 寻找子序列，找到返回第一个索引值，没找到返回 -1,可指定开始位置和结束位置 a = &quot;alex&quot; print(a.find(&quot;l&quot;,0,3)) （5）join() 拼接 a = &quot;alex&quot; print(&quot;+&quot;.join(a)) （6）strip() 删除两边空白 a = &quot; alex &quot; print(a.strip()) （7）split() 拆分 可指定拆分为几份 a = &quot;alex&quot; print(a.split(&quot;l&quot;,2)) （8）upper() 全部转换成大写 a = &quot;alex&quot; print(a.upper()) （8）lower() 全部转换成大写 a = &quot;ALEX&quot; print(a.lower()) （9）format() 格式化，将一个字符串中的占位符替换为指定的值 # 第一种方法 a = &quot;{name},{age}&quot; print(a.format(name=&quot;alex&quot;,age=19)) # 第二种方法 a = &quot;{name},{age}&quot; print(a.format(**{&quot;name&quot;:&quot;alex&quot;,&quot;age&quot;:19})) # 第三种方法 a = &quot;{0},{1}&quot; print(a.format(&quot;alex&quot;,19)) （10）startswith() 以什么开头 endswith() 以什么结尾 a = &quot;alex&quot; print(a.startswith(&quot;al&quot;)) print(a.endswith(&quot;ex&quot;)) （11）center() 填充 默认空白 可指定填充内容 a = &quot;aelx&quot; print(a.center(20,&quot;*&quot;)) 列表（1）append() 追加 a = [11,22,&quot;123&quot;] a.append(&quot;asd&quot;) print(a) （2）extend() 追加 可迭代对象 a = [11,22,&quot;123&quot;] a.extend(&quot;asd&quot;) print(a) （3）insert() 从指定位置插入元素 a = [11,22,&quot;123&quot;] a.insert(0,&quot;asd&quot;) print(a) （4）pop() 移除列表中的一个元素（默认是最后一个），并且返回该元素的值 a = [11,22,&quot;123&quot;] print(a.pop()) print(a.pop(0)) （5）remove() 移除列表中某个值的第一个匹配项 a = [11,22,&quot;123&quot;] a.remove(11) print(a) （6）reverse() 将列表中的元素反向存放 a = [11,22,&quot;123&quot;] a.reverse() print(a) （7）sort() 对列表进行排序 a = [1,3,2,4] a.sort() print(a) 字典（1）get() 根据key获取值，key不在时，可以指定值默认（None） a = { &quot;k1&quot;:2, &quot;k2&quot;:3 } v = a.get(&quot;k111&quot;,111) print(v) （2）update() 更新 # 第一种写法 a = { &quot;k1&quot;:2, &quot;k2&quot;:3 } v = a.update({&quot;k111&quot;:123,&quot;kk122&quot;:333}) print(a) # 第二种写法 a = { &quot;k1&quot;:2, &quot;k2&quot;:3 } v = a.update(k111=123,kk122=333) print(a) （3）keys() 获取key值 a = { &quot;k1&quot;:2, &quot;k2&quot;:3 } for L in a.keys(): print(L) （4）values() 获取value值 a = { &quot;k1&quot;:2, &quot;k2&quot;:3 } for L in a.values(): print(L) （5）items() 获取key、value值 a = { &quot;k1&quot;:2, &quot;k2&quot;:3 } for L in a.items(): print(L) （6）clear() 清除字典中所有的项 a = { &quot;k1&quot;:2, &quot;k2&quot;:3 } a.clear() print(a) （7）del 删除键指定key dict = {&#39;Name&#39;: &#39;Zara&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;} del dict[&#39;Name&#39;] print(dict) 元组（1）元组之间的连接组合 tup1 = (12, 34.56) tup2 = (&#39;abc&#39;, &#39;xyz&#39;) tup3 = tup1 + tup2 print(tup3) （2）删除元组 tup = (&#39;physics&#39;, &#39;chemistry&#39;, 1997, 2000) print(tup) del (tup) print (&quot;After deleting tup : &quot;) print (tup) #因为已经被删除，所以会报错 ：“NameError: name &#39;tup&#39; is not defined” 参考自菜鸟教程https://www.runoob.com/python/python-tuples.html","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"},{"name":"python基础","slug":"python基础","permalink":"https://zhoulei.icu/tags/python基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"算法面试题","slug":"算法面试题","date":"2020-07-09T16:00:00.000Z","updated":"2020-08-05T06:59:48.962Z","comments":true,"path":"2020/07/10/算法面试题/","link":"","permalink":"https://zhoulei.icu/2020/07/10/算法面试题/","excerpt":"","text":"获取指定和的对应索引def get_num_index(llist,target): &#39;&#39;&#39; :param target: 俩个下标值的和 :param llist: 查看下标所用的列表 :return: 返回符合条件的两个下标值 &#39;&#39;&#39; y=0 for x,val in enumerate(llist): y += 1 if llist[x] +llist[y]==target: return (x,y) if __name__ == &#39;__main__&#39;: print(get_num_index([1,2,3,4,5,6],5)) 为何输出为6，6，6，6def num(): &#39;&#39;&#39; :param i=i 外面每循环一次就把i赋值一次 最后可以得到不同的值 如没有 则等外面的循环完毕 i就赋值一个固定的值 3 :return: 返回的是一个列表推导式，里面是一个函数 &#39;&#39;&#39; return [lambda x,i=i:i*x for i in range(4)] if __name__ == &#39;__main__&#39;: print([m(2) for m in num()]) 当我们执行 m(2) 时，运行到num()内部函数，发现变量 i 并不是num()中的变量，于是就到外部函数num中寻找变量 i ，但此时外部的 for 已经循环完毕，最后的 i =3 。所以，每次 执行m(2)，i 的值都是 3 ，因此，最终结果会是 [6, 6, 6, 6] 生成器斐波那契def fib(max): a,b = 0,1 while max &gt; 0: a,b = b,a+b max-=1 yield a for i in fib(10): print(i) 迭代器斐波那契class fibonacci(object): def __init__(self,n): self.n = n self.current = 0 self.a = 0 self.b = 1 def __next__(self): if self.current &lt; self.n: self.a,self.b = self.b,self.a+self.b self.current += 1 return self.a else: raise StopIteration def __iter__(self): return self fib = fibonacci(15) for num in fib: print(num) 可迭代对象去重class Solution(): def isUnique(self,astr:str)-&gt;bool: mes_dict={} for i in astr: if mes_dict.get(i,&quot;&quot;): return False else: mes_dict[i] =1 return True s=Solution() print(s.isUnique(&#39;1233&#39;)) 回文数判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例1： 输入: 121 输出: true 1 2 示例2： 输入: -121 输出: false 解释: 从左向右，为 -121 。 从右向左读，为121- 。 因此它不是一个回文数 1 2 3 示例3： 输入: 10 输出: false 解释: 从右向左读，为 01 。 因此它不是一个回文数 代码 def Palindrome(): num = input() if num == num[::-1]: print(&#39;true&#39;) else: print(&#39;flase&#39;) print(&#39;从左向右读, 为 %s 。 从右向左读, 为 %s 。因此它不是一个回文数&#39; % (num,num[::-1])) 队列实现栈栈需要有四个方法 push(x) 入栈 pop() 移除栈顶元素 top() 获取栈顶元素 empty() – 返回栈是否为空 class Stack(): def __init__(self): #初始化一个空列表 self.stack = [] def push(self,x): &#39;&#39;&#39; :param x :要添加的元素 &#39;&#39;&#39; #列表尾部添加元素 self.stack.append(x) def top(self): #获取列表尾部元素 return self.stack[-1] def pop(self): #获取列表尾部元素并将这个元素从列表中删除 return self.stack.pop() def empty(self): if not self.stack: #如果列表中没有元素，返回True return True else: #如果列表中有元素，返回False return False #实例化一个栈 mystack = Stack() #尾部添加 mystack.push(1) mystack.push(2) # 获取列表尾部元素 print(mystack.top()) #获取栈的尾部元素并将这个元素从栈中删除 print(mystack.pop()) #判断栈是否为空 空返回True 非空返回False print(mystack.empty()) 一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？a = [100] #每个‘反弹落地’过程经过的路程，第1次只有落地（100米） h = 100 #每个‘反弹落地’过程，反弹的高度，第1次为100米 print(&#39;第1次从%s米高落地，走过%s米，之后又反弹至%s米。&#39; % (h, a[0], h/2)) for i in range(2,11): #第1次已初始化，再循环9次 a.append(h) #先计算路程，再高度减半，因为一个‘反弹落地’为2个高度 h = h / 2 print(&#39;第%s次从%s米高落地，共走过%s米，之后又反弹至%s米。&#39; % (i, h, sum(a), h / 2)) 反转字符串中的单词输入: “Let’s take LeetCode contest”输出: “s’teL ekat edoCteeL tsetnoc” 方法一def reverseWords(s): l = s.split() for i in range(len(l)): l[i] = l[i][::-1] return &#39; &#39;.join(l) print(reverseWords(&quot;Let’s take LeetCode contest&quot;)) 方法二def reverseWords(s): return &quot; &quot;.join(s.split()[::-1])[::-1] print(reverseWords(&quot;Let’s take LeetCode contest&quot;))","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"},{"name":"面试题","slug":"面试题","permalink":"https://zhoulei.icu/tags/面试题/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"HeyUI + Django实现分页","slug":"HeyUI + Django实现分页","date":"2020-05-14T04:00:00.000Z","updated":"2020-05-14T01:50:08.146Z","comments":true,"path":"2020/05/14/HeyUI + Django实现分页/","link":"","permalink":"https://zhoulei.icu/2020/05/14/HeyUI + Django实现分页/","excerpt":"","text":"HeyUI自带分页&lt;template&gt; &lt;div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div v-for=&quot;item in goodslist&quot; &gt; &lt;p&gt; &lt;span class=&quot;emphasis&quot;&gt;${{item.price}}&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;br /&gt; &lt;!--heyui分页--&gt; &lt;div&gt; &lt;!-- &lt;Pagination v-model=&quot;pagination&quot; @change=&quot;get_goods&quot; layout=&quot;pager,jumper&quot; small &gt;&lt;/Pagination&gt; --&gt; &lt;Pagination v-model=&quot;pagination&quot; @change=&quot;get_goods&quot;&gt;&lt;/Pagination&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { msg: &quot;这是一个变量&quot;, goodslist: [], goodslist_self: [], //分页器变量 pagination: { page: 1, size: 2, total: 5 }, }; }, mounted: function() { this.get_goods(); }, methods: { //获取商品接口 get_goods() { this.axios .get(&quot;http://127.0.0.1:8000/goodslist/&quot;, { params: { page: this.pagination.page, size: this.pagination.size } }) .then(res =&gt; { console.log(res); this.goodslist = res.data.data; this.pagination.total = res.data.total; }); }, } }; &lt;/script&gt; &lt;style&gt; &lt;/style&gt; 自定义分页&lt;template&gt; &lt;div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div v-for=&quot;item in goodslist&quot; &gt; &lt;p&gt; &lt;span class=&quot;emphasis&quot;&gt;${{item.price}}&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;br /&gt; &lt;!--自主分页容器--&gt; &lt;div&gt; &lt;a @click=&quot;get_goods(1)&quot;&gt;首页&lt;/a&gt; &lt;Button v-show=&quot;lastpage&quot; @click=&quot;get_goods(lastpage)&quot;&gt;上一页&lt;/Button&gt; &amp;emsp;&amp;emsp; &lt;!-- &lt;span v-for=&quot;index in allpage&quot;&gt; &lt;a @click=&quot;get_goods(index)&quot; &gt;{{ index }}&lt;/a&gt;&amp;emsp;&amp;emsp; &lt;/span&gt;--&gt; &amp;emsp;&amp;emsp; &lt;span v-for=&quot;item in last_page&quot;&gt; &lt;a @click=&quot;get_goods(item)&quot;&gt;{{ item }}&lt;/a&gt; &amp;emsp;&amp;emsp; &lt;/span&gt; &lt;a @click=&quot;get_goods(page)&quot;&gt;{{ page }}&lt;/a&gt; &amp;emsp;&amp;emsp; &lt;span v-for=&quot;item in next_page&quot;&gt; &lt;a @click=&quot;get_goods(item)&quot;&gt;{{ item }}&lt;/a&gt; &amp;emsp;&amp;emsp; &lt;/span&gt; &lt;span v-if=&quot;page != allpage&quot;&gt;...&lt;/span&gt; &lt;Button v-show=&quot;nextpage&quot; @click=&quot;get_goods(nextpage)&quot;&gt;下一页&lt;/Button&gt; &lt;a @click=&quot;get_goods(allpage)&quot;&gt;尾页&lt;/a&gt; &lt;input @input=&quot;jump_page($event)&quot; type=&quot;text&quot; style=&quot;width:50px;&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { msg: &quot;这是一个变量&quot;, goodslist: [], //自定义分页 //商品总数 total_self: 0, //上一页 lastpage: 0, //下一页 nextpage: 0, //当前页 page: 1, //总页数 allpage: 0, //每页展示数 size: 1, //分页偏移 last_page: [], next_page: [] }; }, mounted: function() { this.get_goods(1); }, methods: { //页面跳转 jump_page(e) { var val = e.target.value; if (val &gt; this.allpage) { this.$Message(&quot;您输入的页码有误&quot;); return false; } this.get_goods(val); }, //获取商品接口 get_goods: function(page) { //发送请求 this.axios .get(&quot;http://localhost:8000/goodslist/&quot;, { params: { page: page, size: this.size } }) .then(result =&gt; { console.log(result); this.goodslist = result.data.data; //商品总数 this.total_self = result.data.total; //判断上一页 if (page == 1) { this.lastpage = 0; } else { this.lastpage = page - 1; } //计算总页数 this.allpage = Math.ceil(this.total_self / this.size); //判断下一页 if (page == this.allpage) { this.nextpage = 0; } else { this.nextpage = page + 1; } //设置偏移量 var move_page = 2; var my_last = []; //计算左侧偏移量 for (let i = page - move_page; i &lt; page; i++) { if (i &gt; 0) { my_last.push(i); } } //计算右侧偏移量 var my_next = []; for (let i = page + 1; i &lt;= page + move_page; i++) { if (i &lt;= this.allpage) { my_next.push(i); } } this.last_page = my_last; this.next_page = my_next; }); } } }; &lt;/script&gt; &lt;style&gt; &lt;/style&gt; Django后端#商品列表页 class GoodsList(APIView): def get(self,request): #当前页 page = request.GET.get(&#39;page&#39;,1) #一页显示个数 size = request.GET.get(&#39;size&#39;,1) #计算从哪儿开始切 data_start = (int(page)-1)*int(size) #计算切到哪儿 data_end = int(page) * int(size) goods = Goods.objects.all()[data_start:data_end] #查询所有商品个数 count = Goods.objects.count() #Goodsser为已经引入的序列器 goods_ser = GoodsSer(goods,many=True) return Response({ &#39;data&#39;:goods_ser.data, &#39;total&#39;:count })","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"django","slug":"django","permalink":"https://zhoulei.icu/tags/django/"},{"name":"vue","slug":"vue","permalink":"https://zhoulei.icu/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"Vue国际化","slug":"vue国际化","date":"2020-05-09T16:00:00.000Z","updated":"2020-05-10T10:36:59.904Z","comments":true,"path":"2020/05/10/vue国际化/","link":"","permalink":"https://zhoulei.icu/2020/05/10/vue国际化/","excerpt":"","text":"以下以中英双语来示例 首先安装vue-i18nnpm install vue-i18n 新建文件首先在src目录下新建一个lang文件夹，接着在lang文件夹下新建en.js和zh.js两个文件。如图 en.js和zh.js分别用来定义英文和中文 en.js代码如下 //双语规范的变量(英文) export const m = { login:&#39;Login&#39;, logout:&#39;Logout&#39;, register:&#39;Register&#39;, } zh.js代码如下 //双语规范的变量(中文) export const m = { login:&#39;登陆&#39;, logout:&#39;登出&#39;, register:&#39;注册&#39;, } 在main.js文件中写入//国际化导入 import VueI18n from &#39;vue-i18n&#39; //国际化注册 Vue.use(VueI18n); //导入语言包 const i18n = new VueI18n({ //当前默认语言 locale:&#39;zh&#39;, //语言包声明 messages:{ &#39;zh&#39;:require(&#39;./lang/zh&#39;), &#39;en&#39;:require(&#39;./lang/en&#39;) } }) new Vue({ el: &#39;#app&#39;, router, i18n, //在这行写上i18n components: { App }, template: &#39;&lt;App/&gt;&#39;, render: h =&gt; h(App) }) 新建vue文件&lt;template&gt; &lt;div&gt; {{ $t('m.login') }}{{ $t('m.logout') }}{{ $t('m.register') }} &lt;div&gt; &lt;!-- 开关标签 --&gt; &lt;!-- 此标签使用heyui组件 --&gt; &lt;h-switch v-model=&quot;lang&quot; @change=&quot;lang_change&quot;&gt;中/英&lt;/h-switch&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data () { return { //开关变量 lang:0, } }, mounted:function(){ //调用判断语言方法 this.iflang(); methods:{ //判断语言 iflang(){ var lang_locale = localStorage.getItem(&#39;lang&#39;) if(lang_locale){ this.$i18n.locale = lang_locale if(lang_locale == &#39;zh&#39;){ this.lang = 1; }else{ this.lang = 0; } }else{ this.$i18n.locale = &#39;zh&#39; this.lang = 1; } }, //切换语言 lang_change(){ if(this.lang == true){ //中文 this.$i18n.locale =&#39;zh&#39;; localStorage.setItem(&#39;lang&#39;,&#39;zh&#39;) }else{ //英文 this.$i18n.locale =&#39;en&#39;; localStorage.setItem(&#39;lang&#39;,&#39;en&#39;) } }, }， } &lt;/script&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://zhoulei.icu/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"七牛云上传文件","slug":"七牛云上传文件","date":"2020-04-29T16:00:00.000Z","updated":"2020-04-30T04:10:51.482Z","comments":true,"path":"2020/04/30/七牛云上传文件/","link":"","permalink":"https://zhoulei.icu/2020/04/30/七牛云上传文件/","excerpt":"","text":"注册登陆七牛云，不再细述 新建空间 这一步图中的空间名称是演示用，之后我会使用之前已经创建好的应用。 点击上传文件 便可手动上传需要的文件。复制外链之后将之粘贴到浏览器地址栏进行访问，便可看到上传好的文件，当然代码中我们不需要这么操作。 点击密钥管理便可进入该页面 安装pip在命令行中输入 pip install qiniu Django视图from rest_framework.response import Response from rest_framework.views import APIView #七牛云token from qiniu import Auth class Qiniu(APIView): def get(self,request): #声明认证对象 括号中的值分别为密钥管理页面中的AK和SK q = Auth(&#39;uoXTznzcnkvm6NLVKGC5R4PTCf9bYZwJBLCkEvAl&#39;, &#39;gezvzPNb1T9DjYFgt7BzIh9yGoZ50Zwy_GTGCEY9&#39;) #获取token token = q.upload_token(&#39;upload1907a&#39;) #这里要写自己的空间名称 return Response({&#39;token&#39;:token}) urls.py文件from django.urls import path from myapp.md_user import Qiniu urlpatterns = [ path(&#39;qiniu/&#39;,Qiniu.as_view()), ] Vue&lt;template&gt; &lt;div&gt; &lt;section class=&quot;featured-block text-center&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div&gt; &lt;!-- &lt;img :src=&quot;src&quot; alt=&quot;&quot;&gt; --&gt; &lt;Avatar :src=&#39;src&#39; :width=&#39;150&#39; fit=&#39;fill&#39;&gt;&lt;/Avatar&gt; &lt;/div&gt; &lt;div&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt; 七牛云上传 &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;file&quot; @change=&#39;upload&#39;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data () { return { msg: &quot;这是一个变量&quot;, src:&#39;&#39;, } }, mounted:function(){ }, methods:{ //获取token get_token(){ //请求后台接口 this.axios.get(&#39;http://127.0.0.1:8000/qiniu/&#39;).then(res=&gt;{ console.log(res.data.token) this.token = res.data.token }) }, upload(e){ //获取文件 let file = e.target.files[0]; //声明表单参数 let param = new FormData(); param.append(&#39;file&#39;,file,file.name); param.append(&#39;token&#39;,this.token); //自定义axios const axios_qiniu = this.axios.create({withCredentials:false}); //发送请求 axios_qiniu({ method:&#39;POST&#39;, url:&#39;http://up-z1.qiniu.com/&#39;, data:param, timeout:30000, }).then(res=&gt;{ console.log(res); this.src = &#39;http://q9ksbfyle.bkt.clouddn.com/&#39;+res.data.key }) }, } } &lt;/script&gt; &lt;style&gt; td { padding: 10px; } &lt;/style&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"django","slug":"django","permalink":"https://zhoulei.icu/tags/django/"},{"name":"vue","slug":"vue","permalink":"https://zhoulei.icu/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"Django + Vue 上传图片","slug":"Django + Vue 上传图片","date":"2020-04-28T16:00:00.000Z","updated":"2020-04-29T10:00:11.334Z","comments":true,"path":"2020/04/29/Django + Vue 上传图片/","link":"","permalink":"https://zhoulei.icu/2020/04/29/Django + Vue 上传图片/","excerpt":"","text":"流程图 Vue&lt;template&gt; &lt;div&gt; &lt;section class=&quot;featured-block text-center&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div&gt; &lt;!-- &lt;img :src=&quot;src&quot; alt=&quot;&quot;&gt; --&gt; &lt;Avatar :src=&#39;src&#39; :width=&#39;150&#39; fit=&#39;fill&#39;&gt;&lt;/Avatar&gt; &lt;/div&gt; &lt;div&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt; 用户头像 &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;file&quot; @change=&#39;upload&#39;&gt; &lt;/td&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data () { return { src:&#39;&#39;, } }, mounted:function(){ }, methods:{ //请求后台接口 upload(e){ //获取文件 let file = e.target.files[0]; //声明表单参数 let param = new FormData(); param.append(&#39;file&#39;,file,file.name); //声明请求头 let config = {headers:{&#39;Content-Type&#39;:&#39;multipart/form-data&#39;}} //请求后台接口 this.axios.post(&#39;http://localhost:8000/upload/&#39;,param,config).then(res=&gt;{ this.$Message(res.data.mes) console.log(res); this.src = &#39;http://127.0.0.1:8000/static/upload/&#39;+res.data.filename }) }, } } &lt;/script&gt; &lt;style&gt; td { padding: 10px; } &lt;/style&gt; Django导包from rest_framework.response import Response from rest_framework.views import APIView #导入时间模块 import time import cv2 #导入图片库 #绘画库 from PIL import ImageDraw #字体库 from PIL import ImageFont #图片库 from PIL import Image #导入上传文件夹配置 from mydjango.settings import UPLOAD_ROOT settings.py文件最后一行写入 #定义上传文件夹的路径 UPLOAD_ROOT = os.path.join(BASE_DIR,&#39;static/upload&#39;) static目录下新建upload文件夹 代码#文件上传通用类 class UploadFile(APIView): #post请求没有长度要求 def post(self,request): #接收参数 myfile = request.FILES.get(&#39;file&#39;) #设置时间戳 time_stamp = str(int(time.time())) #设置图片名 img_name = time_stamp + myfile.name #建立文件流对象 f = open(os.path.join(UPLOAD_ROOT,&#39;&#39;,img_name),&#39;wb&#39;) #写入 for chunk in myfile.chunks(): f.write(chunk) f.close() # 图像压缩 img = cv2.imread(UPLOAD_ROOT+&#39;/&#39;+img_name) # jpg 压缩等级 0-100 cv2.imwrite(UPLOAD_ROOT+&#39;/&#39;+img_name,img,[cv2.IMWRITE_JPEG_QUALITY,50]) # 读图 im = Image.open(UPLOAD_ROOT+&#39;/&#39;+img_name) #获取图片的长和宽 im_width,im_height = im.size #设置水印字体和大小 font = ImageFont.truetype(r&#39;‪C:\\Windows\\Fonts\\simkai.ttf&#39;,150) #生成画笔 draw = ImageDraw.Draw(im) # #绘制 参数分别为坐标，文字，透明色 draw.text((im_width/2,im_height/2),&#39;周磊&#39;,fill=(76,234,124,180),font=font) # 存储图片 im.save(UPLOAD_ROOT+&#39;/&#39;+img_name) return Response({ &#39;filename&#39;:img_name })","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"django","slug":"django","permalink":"https://zhoulei.icu/tags/django/"},{"name":"vue","slug":"vue","permalink":"https://zhoulei.icu/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"微博第三方登录","slug":"微博三方登录","date":"2020-04-27T16:00:00.000Z","updated":"2020-04-28T09:27:41.621Z","comments":true,"path":"2020/04/28/微博三方登录/","link":"","permalink":"https://zhoulei.icu/2020/04/28/微博三方登录/","excerpt":"","text":"什么叫第三方登陆 第三方登录，是相对于应用而言，用户登录操作基于的是非自身建设账号体系，而是基于用户在第三方平台上已有的账号和密码来快速完成登录的过程。目前国内比较广泛使用的第三方登录方式为微博、微信、QQ等，国外广泛使用的登录方式为Facebook，Twitter等。 比如网易云音乐，我们可以不注册网易云账号，直接使用QQ账户进行登陆，这时QQ就是除网易云音乐和我们用户之外的第三方。 为什么要使用第三方登陆1.方便用户快捷登录，降低用户的登录流失率站在用户的角度来说，自然是希望一个账号可以在多个平台使用，不然每个平台都注册一遍，过一段时间 可能连密码都忘了，而第三方登陆免去了用户输入账号密码的繁杂操作，便是提升了用户体验。 2.方便应用获取用户信息，减少产品设计成本第三方登录接入后，应用可直接获取用户昵称、头像、用户ID等信息，方便产品获取用户的基本资料 3.减少短信验证码发送次数，降低产品登录成本目前市面上的短信验证码的价钱约在0.05元左右，当用户选择使用第三方登录时，可有效减少产品的登录成本 如何使用第三方登陆 以下以微博第三方登陆为例，因为是简单的演示过程，所以不太严谨 注册登陆微博开放平台 此过程不必细述，简单的注册登录 微博开放平台：https://open.weibo.com/ 创建应用 创建好之后便会跳到此应用的信息页面，因为只是简单的测试，我们可以先不提交审核，也是可以测试登陆功能的。 在高级信息中设置回调页 代码django后端 代码中的client_id与client_secret分别使用基本信息中的App Key与App Secret的值，忘记请回看创建应用中的第四步 redirect_uri为已经定义好的回调页，忘记请回看创建应用中的第五步 需要的包from django.shortcuts import redirect import requests import json 代码逻辑def weibo(request): #接收参数 code = request.GET.get(&#39;code&#39;,None) #定义token的接口地址 url = &#39;https://api.weibo.com/oauth2/access_token&#39; #定义参数 re = requests.post(url,data={ &#39;client_id&#39;:&#39;1313226958&#39;, &#39;client_secret&#39;:&#39;cf9c28cf12db66ed57f2ba04c3bf2fdb&#39;, &#39;grant_type&#39;:&#39;authorization_code&#39;, &#39;code&#39;:code, &#39;redirect_uri&#39;:&#39;http://127.0.0.1:8000/weibo/&#39; }) print(re.json()) # 换取新浪微博用户昵称 res = requests.get(&#39;https://api.weibo.com/2/users/show.json&#39;,params={&#39;access_token&#39;:re.json()[&#39;access_token&#39;],&#39;uid&#39;:re.json()[&#39;uid&#39;]}) print(res.json()) sina_id = &#39;&#39; user_id = &#39;&#39; #判断是否用新浪微博登陆过 user = User.objects.filter(username = str(res.json()[&#39;name&#39;])).first() if user: #代表曾经用该账号登陆过 sina_id = user.username user_id = user.id else: #首次登陆 user = User(username=str(res.json()[&#39;name&#39;])) user.save() user = User.objects.filter(username = str(res.json()[&#39;name&#39;])).first() sina_id = user.username user_id = user.id return redirect(&#39;http://localhost:8080/sina_id=&#39;+str(sina_id)+&#39;&amp;uid=&#39;+str(user_id)) 路由打开urls.py文件 from django.contrib import admin from django.urls import path from myapp.md_user import weibo,dingding_back urlpatterns = [ path(&#39;weibo/&#39;,weibo), #这里也务必要和回调页相同 ] vue前端 代码中的client_id使用基本信息中的App Key的值，忘记请回看创建应用中的第四步 redirect_uri为已经定义好的回调页，忘记请回看创建应用中的第五步 methods:{ //新浪微博三方登陆 sina(){ //拼接url let client_id = 1313226958; let url = &#39;https://api.weibo.com/oauth2/authorize?client_id=&#39;+client_id + &#39;&amp;redirect_uri=http://127.0.0.1:8000/weibo/&#39;; //跳转 window.location.href = url }, } 流程图 再次强调，回调页设置的地址，一定要和代码中的一样才能保证功能正常。","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"django","slug":"django","permalink":"https://zhoulei.icu/tags/django/"},{"name":"web","slug":"web","permalink":"https://zhoulei.icu/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"selenium自动登陆","slug":"selenium自动登陆","date":"2020-04-26T16:00:00.000Z","updated":"2020-04-27T09:06:20.080Z","comments":true,"path":"2020/04/27/selenium自动登陆/","link":"","permalink":"https://zhoulei.icu/2020/04/27/selenium自动登陆/","excerpt":"","text":"导包import requests import base64 import urllib from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains import time import json import cv2 代码 #建立浏览器对象 browser = webdriver.Chrome() #打开网址 browser.get(&#39;http://localhost:8080/login&#39;) time.sleep(1) #选择元素 myimg = browser.find_element_by_xpath(&#39;/html/body/div[1]/div/section/div/div[2]/table/tr[4]/td[2]/img&#39;) #截取元素图 也就是页面中要是别的图片验证码 myimg.screenshot(&#39;login.png&#39;) #读图 imgs = cv2.imread(&#39;./login.png&#39;,cv2.IMREAD_GRAYSCALE) #写图 将图片降噪并保存，也就是将图片中的验证变为黑白色，提高识别率 cv2.imwrite(&#39;./login1.png&#39;,imgs) #selenium 截图 这里是截取整个页面，一般不用 # browser.get_screenshot_as_file(&#39;register.png&#39;) #请求百度接口 res = requests.get(&quot;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=7BzC4ag74TgA2BSGCGDV9445&amp;client_secret=E31EUMUyPHGv4ViWP21tq4ODCfEHLqib&quot;) #转码 res = json.loads(str(res.text)) token = res[&#39;access_token&#39;] #识别图像 url = &#39;https://aip.baidubce.com/rest/2.0/ocr/v1/accurate_basic?access_token=&#39; + token #构造头部 header = {&#39;Content-Type&#39;:&#39;application/x-www-form-urlencoded&#39;} #构造图片 img = open(&#39;./login1.png&#39;,&#39;rb&#39;) temp_img = img.read() #构建参数 data = {&#39;image&#39;:base64.b64encode(temp_img)} #编码 data = urllib.parse.urlencode(data) #发送请求 res = requests.post(url=url,data=data,headers=header) #将json数据转为python数据格式 code = json.loads(res.text) #获取验证码 code = code[&#39;words_result&#39;][0][&#39;words&#39;] print(code) # 填入用户信息 browser.find_element_by_xpath(&#39;/html/body/div[1]/div/section/div/div[2]/table/tr[1]/td[2]/input&#39;).send_keys(&#39;123&#39;) browser.find_element_by_xpath(&#39;/html/body/div[1]/div/section/div/div[2]/table/tr[2]/td[2]/input&#39;).send_keys(&#39;123&#39;) #填入验证码 browser.find_element_by_xpath(&#39;/html/body/div[1]/div/section/div/div[2]/table/tr[3]/td[2]/input&#39;).send_keys(code.strip().replace(&#39; &#39;,&#39;&#39;)) #定位滑块选择器 button = browser.find_element_by_class_name(&#39;dv_handler&#39;) #建立动作对象 action = ActionChains(browser) #按住拖动 action.click_and_hold(button).perform() #动作释放 action.reset_actions() #获取总长度 mytest = browser.find_element_by_class_name(&#39;dv_text&#39;) print(mytest.size.get(&#39;width&#39;)) #获取滑块长度 print(button.size.get(&#39;width&#39;)) #拖动位置 action.move_by_offset(mytest.size.get(&#39;width&#39;)-button.size.get(&#39;width&#39;),0).perform() #登录按钮 browser.find_element_by_xpath(&#39;/html/body/div[1]/div/section/div/div[2]/table/tr[6]/td[2]/button/span&#39;).click() time.sleep(3) browser.close()","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://zhoulei.icu/tags/vue/"},{"name":"python","slug":"python","permalink":"https://zhoulei.icu/tags/python/"},{"name":"后端","slug":"后端","permalink":"https://zhoulei.icu/tags/后端/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"利用百度智能云识别图片验证码","slug":"利用百度智能云识别图片验证码","date":"2020-04-25T16:00:00.000Z","updated":"2020-04-26T10:20:07.857Z","comments":true,"path":"2020/04/26/利用百度智能云识别图片验证码/","link":"","permalink":"https://zhoulei.icu/2020/04/26/利用百度智能云识别图片验证码/","excerpt":"","text":"百度智能云 请自行完成注册登录 进入百度智能云文字识别 创建应用 接着填入应用名称和应用描述，点击立即创建 然后查看应用列表，便可看到新增的应用 点击显示可以看到隐藏的Secret Key , 这里的API Key 和 Secret Key后面会用到，请保存好 代码需要导入的包import requests import base64 import urllib 代码#获取token #需要的两个参数 client_id 和 client_secret 分别是我们的 API Key 和 Secret Key res = requests.get(&#39;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=7BzC4ag74TgA2BSGCGDV9445&amp;client_secret=E31EUMUyPHGv4ViWP21tq4ODCfEHLqib&#39;) access_token = res.json()[&#39;access_token&#39;] #开始智能视图 #接口地址 此接口为百度智能云提供 url = &#39;https://aip.baidubce.com/rest/2.0/ocr/v1/accurate_basic?access_token=&#39;+access_token #定义头部信息 myheaders = {&#39;Content-Type&#39;:&#39;application/x-www-form-urlencoded&#39;} #操作图片 #读取图片 myimg = open(&#39;./code.png&#39;,&#39;rb&#39;) #这里便是验证码图片 temp_img = myimg.read() myimg.close() #进行base64编码 temp_data = {&#39;image&#39;:base64.b64encode(temp_img)} #对图片地址进行 temp_data = urllib.parse.urlencode(temp_data) #请求识图接口 res = requests.post(url=url,data=temp_data,headers=myheaders) code = res.json()[&#39;words_result&#39;][0][&#39;words&#39;] code = str(code).replace(&#39; &#39;,&#39;&#39;) print(code) #结果就是识别出的验证码","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"python","slug":"python","permalink":"https://zhoulei.icu/tags/python/"},{"name":"后端","slug":"后端","permalink":"https://zhoulei.icu/tags/后端/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"Python操作Redis的5种数据类型","slug":"Python操作Redis的5种数据类型","date":"2020-04-24T16:00:00.000Z","updated":"2020-04-25T12:24:33.829Z","comments":true,"path":"2020/04/25/Python操作Redis的5种数据类型/","link":"","permalink":"https://zhoulei.icu/2020/04/25/Python操作Redis的5种数据类型/","excerpt":"","text":"导包import redis 建立连接#定义ip和端口 host = &#39;localhost&#39; port = 6379 #建立连接 r = redis.Redis(host=host,port=port) 五大类型操作 以下结果中 ‘ ’ 单引号外边的 b 表示 字节 类型 字符串类型 String# ex过期时间 单位秒S r.set(&#39;name&#39;, &#39;Jack&#39;, ex=20) ret = r.get(&#39;name&#39;) print(ret) 结果 过期前： b&#39;Jack&#39; 过期后： None 列表类型 list r.lpush(&#39;object&#39;, &#39;one&#39;) r.lpush(&#39;object&#39;, &#39;two&#39;) r.lpush(&#39;object&#39;, &#39;three&#39;) r.lpush(&#39;object&#39;, &#39;four&#39;) r.lpush(&#39;object&#39;, &#39;five&#39;) r.lpush(&#39;object&#39;, &#39;six&#39;) ret = r.lrange(&#39;object&#39;, 0, 5) print(ret[::-1], len(ret)) 结果 [b&#39;one&#39;, b&#39;two&#39;, b&#39;three&#39;, b&#39;four&#39;, b&#39;five&#39;, b&#39;six&#39;] 6 哈希类型 hashr.hset(&#39;userinfo&#39;, &#39;name&#39;, &#39;Jack&#39;) r.hset(&#39;userinfo&#39;, &#39;age&#39;, 20) r.hset(&#39;userinfo&#39;, &#39;phone&#39;, &#39;110110110110&#39;) r.hset(&#39;userinfo&#39;, &#39;email&#39;, &#39;123@gmail.com&#39;) ret = r.hgetall(&#39;userinfo&#39;) print(ret) 结果 {b&#39;name&#39;: b&#39;Jack&#39;, b&#39;age&#39;: b&#39;20&#39;, b&#39;phone&#39;: b&#39;110110110110&#39;, b&#39;email&#39;: b&#39;123@gmail.com&#39;} 有序集合类型 sorted setr.zadd(&quot;ret1&quot;, n1=11, n2=22) r.zadd(&quot;ret2&quot;, &#39;m1&#39;, 22, &#39;m2&#39;, 44) print(r.zcard(&quot;ret1&quot;)) print(r.zcard(&quot;ret2&quot;)) print(r.zrange(&quot;ret1&quot;, 0, -1)) print(r.zrange(&quot;ret2&quot;, 0, -1, withscores=True)) 结果 2 2 [b&#39;n1&#39;, b&#39;n2&#39;] [(b&#39;m1&#39;, 22.0), (b&#39;m2&#39;, 44.0)]","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"django","slug":"django","permalink":"https://zhoulei.icu/tags/django/"},{"name":"python","slug":"python","permalink":"https://zhoulei.icu/tags/python/"},{"name":"后端","slug":"后端","permalink":"https://zhoulei.icu/tags/后端/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"生成图片验证码","slug":"生成图片验证码","date":"2020-04-23T16:00:00.000Z","updated":"2020-04-26T08:43:15.465Z","comments":true,"path":"2020/04/24/生成图片验证码/","link":"","permalink":"https://zhoulei.icu/2020/04/24/生成图片验证码/","excerpt":"","text":"需要导入的包from django.http import HttpResponse #导入类视图 from django.views import View #绘画库 from PIL import ImageDraw #字体库 from PIL import ImageFont #图片库 from PIL import Image #随机库 import random #文件流 import io #redis包 import redis #定义ip和端口 host = &#39;localhost&#39; port = 6379 #建立连接 r = redis.Redis(host=host,port=port) 代码#自定义图片验证码 class MyCode(View): #定义rbg随机颜色 def get_random_color(self): R = random.randrange(255) G = random.randrange(255) B = random.randrange(255) #三原色 R=Red G=Green B=Blue return (R,G,B) #定义图片视图 def get(self,request): #画布 img_size = (120,50) #定义图片对象 image = Image.new(&#39;RGB&#39;,img_size,&#39;white&#39;) #定义画笔 draw = ImageDraw.Draw(image,&#39;RGB&#39;) #验证码将会从变量source中随机产生 source = &#39;0123456789wrethygtrshh&#39; #接受容器 code_str = &#39;&#39; for i in range(4): #获取字母颜色 text_color = self.get_random_color() #获取随机下标 tmp_num = random.randrange(len(source)) #随机字符串 random_str = source[tmp_num] #装入容器 code_str += random_str #绘制字符串 draw.text((10+30*i,20),random_str,text_color) #获取缓存区 buf = io.BytesIO() #将临时图片保存到缓存 image.save(buf,&#39;png&#39;) #保存随机码 r.set(&#39;code&#39;,code_str) print(r.get(&#39;code&#39;)) return HttpResponse(buf.getvalue(),&#39;image/png&#39;)","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"django","slug":"django","permalink":"https://zhoulei.icu/tags/django/"},{"name":"后端","slug":"后端","permalink":"https://zhoulei.icu/tags/后端/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"MD5加密","slug":"md5加密","date":"2020-04-23T04:00:00.000Z","updated":"2020-04-23T06:49:54.796Z","comments":true,"path":"2020/04/23/md5加密/","link":"","permalink":"https://zhoulei.icu/2020/04/23/md5加密/","excerpt":"","text":"#导入加密库 import hashlib #md5加密方法 def make_password(): #定义字符串 mypass = &#39;123&#39; #生成md5对象 md5 = hashlib.md5() #转码 mypass_utf8 = str(mypass).encode(encoding=&quot;utf-8&quot;) #加密操作 md5.update(mypass_utf8) #返回密文 return md5.hexdigest() print(&#39;生成的md值为：&#39;,make_password()) 输出后的结果 生成的md值为： 202cb962ac59075b964b07152d234b70","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"django","slug":"django","permalink":"https://zhoulei.icu/tags/django/"},{"name":"后端","slug":"后端","permalink":"https://zhoulei.icu/tags/后端/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"VS Code添加open with code功能，实现右键打开文件夹","slug":"vs code添加open with code功能，实现右键打开文件夹","date":"2020-04-22T16:00:00.000Z","updated":"2020-04-23T02:11:14.339Z","comments":true,"path":"2020/04/23/vs code添加open with code功能，实现右键打开文件夹/","link":"","permalink":"https://zhoulei.icu/2020/04/23/vs code添加open with code功能，实现右键打开文件夹/","excerpt":"","text":"首先进入VS Code的安装目录比如我的安装目录为F:\\Microsoft VS Code 在这个目录中新建一个文件，文件名随意，但后缀一定要是.reg ，比如我的为 Open File With Vs code.reg 将这个文件夹用记事本打开，或者也可以用各种编辑器，将以下内容写入，而且以下内容中的所有路径，都要改为你自己的VS Code路径 Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\*\\shell\\VSCode] @=&quot;Open with Code&quot; &quot;Icon&quot;=&quot;F:\\\\Microsoft VS Code\\\\Code.exe&quot; [HKEY_CLASSES_ROOT\\*\\shell\\VSCode\\command] @=&quot;\\&quot;F:\\\\Microsoft VS Code\\\\Code.exe\\&quot; \\&quot;%1\\&quot;&quot; Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\shell\\VSCode] @=&quot;Open with Code&quot; &quot;Icon&quot;=&quot;F:\\\\Microsoft VS Code\\\\Code.exe&quot; [HKEY_CLASSES_ROOT\\Directory\\shell\\VSCode\\command] @=&quot;\\&quot;F:\\\\Microsoft VS Code\\\\Code.exe\\&quot; \\&quot;%V\\&quot;&quot; Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\VSCode] @=&quot;Open with Code&quot; &quot;Icon&quot;=&quot;F:\\\\Microsoft VS Code\\\\Code.exe&quot; [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\VSCode\\command] @=&quot;\\&quot;F:\\\\Microsoft VS Code\\\\Code.exe\\&quot; \\&quot;%V\\&quot;&quot; 改完后记得保存并关闭，再双击这个文件将之打开，win10可能会出现类似于下图的提示 出现类似提示，点击确定就好，之后便完成了所有操作，便可以右键用VS Code打开文件夹","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"},{"name":"web","slug":"web","permalink":"https://zhoulei.icu/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"Vue目录详解","slug":"Vue目录详解","date":"2020-04-21T16:00:00.000Z","updated":"2020-04-22T10:18:56.980Z","comments":true,"path":"2020/04/22/Vue目录详解/","link":"","permalink":"https://zhoulei.icu/2020/04/22/Vue目录详解/","excerpt":"","text":"vue-cli目录结构： 详解首先是介绍最外层文件 build 文件夹：用于存放 webpack 相关配置和脚本。开发中仅 偶尔使用 到此文件夹下 webpack.base.conf.js 用于配置 less、sass等css预编译库，或者配置一下 UI 库 config 文件夹：主要存放配置文件，用于区分开发环境、线上环境的不同。 常用到此文件夹下 config.js 配置开发环境的 端口号、是否开启热加载 或者 设置生产环境的静态资源相对路径、是否开启gzip压缩、npm run build 命令打包生成静态资源的名称和路径等 dist 文件夹：上图没有显示默认 npm run build 命令打包生成的静态资源文件，用于生产部署（我没有打包，所以上图并没有出现dist文件夹） node_modules 文件夹：存放npm命令下载的开发环境和生产环境的依赖包 src 文件夹: 存放项目源码及需要引用的资源文件 static 文件夹: 存放图片之类的静态文件 package.json：用于 node_modules资源部 和 启动、打包项目的 npm 命令管理 src目录结构 assets：存放项目中需要用到的资源文件，css、js、images等 componets文件夹：存放vue开发中一些公共组件：header.vue、footer.vue等 router文件夹：vue-router vue路由的配置文件 App.vue: App.vue就是main.js里的App,当路由文件根据路径匹配到组件时,将组件渲染到&lt;router-view/&gt;标签所在的位置，具体代码作用见下图 &lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;router-view/&gt; &lt;!--路由文件匹配的组件渲染在这里--&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;App&#39; /*其他文件引入该组件时的名称*/ } &lt;/script&gt; &lt;style&gt; #app { font-family: &#39;Avenir&#39;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } &lt;/style&gt; main.js: 主要创建Vue实例,使路由router文件和总组件App结合起来,具体代码作用见下图 import Vue from &#39;vue&#39; import App from &#39;./App.vue&#39; /*引入组件文件*/ import router from &#39;./router&#39; /*引入路由文件夹*/ Vue.config.productionTip = false; new Vue({ /*创建初始Vue实例*/ el: &#39;#app&#39;, /*组件App里的div */ router, /*路由*/ components: { App }, /*Vue实例的组件*/ template: &#39;&lt;App/&gt;&#39; /*渲染模板*/ }); src目录结构​ 因为只有一个index.js文件，我就不配图了 index.js是路由文件夹router下面的默认路由文件,具体代码作用见下图 import Vue from &#39;vue&#39; import Router from &#39;vue-router&#39; import HelloWorld from &#39;@/components/HelloWorld&#39; /*引入HelloWorld组件*/ Vue.use(Router) export default new Router({ mode : &#39;history&#39;, /*去掉访问路径的#号*/ routes: [ { path: &#39;/helloworld&#39;, /*http://localhost:8080/#/helloworld*/ name: &#39;HelloWorld&#39;, /*命名空间*/ component: HelloWorld /*HellodWorld组件,即HelloWorld.vue*/ } ] }) 简易流程文件通讯流程","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://zhoulei.icu/tags/vue/"},{"name":"web","slug":"web","permalink":"https://zhoulei.icu/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"hexo博客上传后自定义域名无法访问博客","slug":"hexo d 之后git pages 自定义域名失效","date":"2020-04-20T16:00:00.000Z","updated":"2020-04-21T12:42:04.252Z","comments":true,"path":"2020/04/21/hexo d 之后git pages 自定义域名失效/","link":"","permalink":"https://zhoulei.icu/2020/04/21/hexo d 之后git pages 自定义域名失效/","excerpt":"","text":"注：如果你没有购买域名的话，这篇文章边便看不看都无所谓了。 问题之前的博客说过，使用hexo d 之后可以将博客上传至github上，但是之后每次更新博客新建md文件，使用 hexo d 再次上传到github pages仓库，settings中的custom domain就变成空的了。 解决在 hexo 生成的博客的 source 目录下新建一个 CNAME 文件，然后在这个文件中填入自己的域名，这样就不会每次上传之后，gitpages 里的 custom domain 都被重置掉啦。 注： 文件名为 CNAME，全部大写，没有后缀。 内容只能有域名，前边不能有www. 或者 http: 等。 如何创建没有后缀的文件（只要创建文本文档的时候把后缀名也给删掉，直接写文件名就好啦。） 可以用记事本方式打开 或者 编辑器打开编辑内容。","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"},{"name":"web","slug":"web","permalink":"https://zhoulei.icu/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"vue安装及基本语法","slug":"vue安装以及简单语法","date":"2020-04-20T16:00:00.000Z","updated":"2020-04-21T13:09:22.655Z","comments":true,"path":"2020/04/21/vue安装以及简单语法/","link":"","permalink":"https://zhoulei.icu/2020/04/21/vue安装以及简单语法/","excerpt":"","text":"一、 node安装如果不确定自己是否安装了node,可以在命令行工具内执行： node -v （检查一下 版本）； 如果 执行结果显示： xx 不是内部命令，说明你还没有安装node , node 安装地址：http://nodejs.cn/download/ 注 ：安装 vue-cli 脚手架目前需要node版本为 v4.0 以上； 二、 vue-cli 全局安装 命令行执行 : npm install -g vue-cli // 加-g是安装到全局 安装完成以后 可以输入命令 ：vue 回车，可以看到针对vue的命令行； **: 如果npm在国内的网络环境下可能会比较慢，解决方案： 使用淘宝镜像: 官方网址：http://npm.taobao.org； 安装：npm install cnpm -g –registry=https://registry.npm.taobao.org； 注意：安装完后最好查看其版本号cnpm -v或关闭命令提示符重新打开，安装完直接使用有可能会出现错误 注：cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm（以下操作将以cnpm代替npm） 如何更新npm的方法： 可以使用 npm install -g npm 来更新版本 三、初始化项目命令为 vue init webpack 项目名 项目名称随意，我这里想把名称写为demo，所以命令为 vue init webpack demo 执行之后将会 自动初始化一个文件夹 ：demo 手动打开demo文件夹 可以看到 已经初始化好了 一个基本的项目： 四、启动项目继续执行： cd demo (这是进入到demo文件夹的命令) 然后执行 安装 ：npm install 注： npm install 执行可以进行vue已经vue的插件安装，在第三步的时候，已经初始化了项目，并且在 package.json 里面已经有相关配置，所以在这里可以直接安装； 安装完成之后再执行命令： npm run dev 然后可以看到 然后将 后边的的 http://localhost:8080/ 复制粘贴到浏览器地址栏 整个项目就已经启动了： 五、项目文件配置介绍build 和 config 是关于webpack的配置，里面包括一些server,和端口； node_modules: 安装依赖代码库； src : 存放源码； static：存放第三方静态资源的，static里面的.gitkeep，如果为空，也可以提交到gitHub上面，正常情况下，是不可以提交的。 入口文件： index.html 和 main.js Vue基础语法 V-model 数据双向绑定 单向：数据变 -&gt; 页面变 V-bind：属性绑定 V-on：事件绑定 V-clock：避免差值表达式所带来的闪烁问题 V-HTML：会将绑定的内容转义输出为HTML，&lt;h1&gt;&lt;/h1&gt; V-Text：不会转义输出 V-if：不保留不存在的条件语句 V-show：保留存在的，只是样式设置为了display:none V-for：v in xxx","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"},{"name":"web","slug":"web","permalink":"https://zhoulei.icu/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"静态博客图片上传","slug":"静态博客图片上传","date":"2020-04-20T16:00:00.000Z","updated":"2020-04-21T02:28:35.401Z","comments":true,"path":"2020/04/21/静态博客图片上传/","link":"","permalink":"https://zhoulei.icu/2020/04/21/静态博客图片上传/","excerpt":"","text":"先前已经把博客搭建好了，但是写博客没有图片怎么能忍，所以来说说图片上传问题 目前我知道有两种方法 方法一、创建Images文件夹1、cd到博客等根目录下 查看_config.yml文件 查找 post_asset_folder 字段确定post_asset_folder 设置为true -&gt; post_asset_folder:true 2、当您设置 post_asset_folder 参数后，在建立文件时，Hexo 会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，这样你就可以更方便的使用资源。 3、在博客的根目录执行命令来进行插件的安装。 npm install https://github.com/CodeFalling/hexo-asset-image –save 4、然后创建一文章 hexo new &quot;test&quot; 然后查看博客的 ../source/_posts 目录下的文件，会看到存在一个test 文件夹 和 test.md 文件 5、将所需要的图片资源放到test 文件夹 内 目录结构如下： 6、书写文章使用test文件内 的图片 7、使用hexo s 命令运行本地博客如图 8、使用hexo clean hexo g hexo deploy 将本地博客推送到远程。 方法二、使用图床 简单说图床就是一个在网络上存储图片的地方，目的是为了节省本地服务器空间，加快图片打开速度，主要是个人博客和网站使用，我也就是想省一下github pages空间 这里推荐几个图床网站 SM.SM meotu z4a 聚合图床 牛图网 imgbb 详细介绍请看这里 https://www.jianshu.com/p/c35091dcba84 我以SM.SM为例 首先进入该网站,看下图。 上传成功后点击image URL，并复制下方的链接。 使用md语法插入图片，将链接粘贴到 输入图片路径中链接中，稍等片刻，图片便会加载好出现。 接着便是hexo g …. 等等正常操作了","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"},{"name":"web","slug":"web","permalink":"https://zhoulei.icu/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"Github Pages + Hexo搭建静态博客","slug":"Github Pages + Hexo搭建静态博客","date":"2020-04-19T16:00:00.000Z","updated":"2020-04-21T02:28:56.657Z","comments":true,"path":"2020/04/20/Github Pages + Hexo搭建静态博客/","link":"","permalink":"https://zhoulei.icu/2020/04/20/Github Pages + Hexo搭建静态博客/","excerpt":"","text":"写给想要拥有一个自己的网站但没有资金成本的小白与曾经的自己。 前言以下的链接除了github仓库，其他都不是我本人的 ，是制作博客主题的作者的链接，请不要混淆。 虽说是网站，对于个人来说，或许一般叫作博客。但我不希望它仅仅是一个博客，而是能够成为一个处于自己现实生活之外、自由、实验、不用畏惧他人眼光甚至可以独断专行的地方。 已经有所基础的同学大可跳读或者直接关闭。 关键词 Hexo 静态博客 无服务器 GitHub Pages hexo-theme-yun 步骤安装 Node.js 什么是 Node.js ？ 这得从什么是 JS 说起，JS 也就是 JavaScript。（为什么有种从盘古开天辟地开始的感觉）没错，JavaScript 就是网页的盘古。JavaScript 是一种编程语言，我们所见到的网页中的交互和逻辑处理几乎都是由 JavaScript 完成。JavaScript 语法简单，易学易用。（当然也请不要小瞧它，虽然它入门门槛低，但上限同样也很高。包括但不限于实现网站前后端，手机桌面应用程序，机器学习，计算机图形学等。）在 Node.js 诞生前，JavaScript 都运行于浏览器端。也就是说，它是鱼，浏览器是装满了水的水缸。2008 年，Chrome V8 诞生。2009 年，Node.js 诞生。并成为 GitHub 早期最著名的开源项目。GitHub 可能大家已有所了解，后续再说。Node.js 便是一个基于 Chrome V8 引擎的 JavaScript 运行环境。（当年第一次看到这句话时，我也一脸懵逼。）按照我的理解，JavaScript 是鱼，Chrome V8 就是抽水机，Node.js 则把这台抽水机也装在你电脑上。于是你的电脑也有了 Node.js 这个和浏览器相似的水缸，也可以在里面运行 JavaScript 了！当然 Node.js 和浏览器端还是因为自身定位和一些历史原因而有些许区别的，不再展开。 建议下载长期支持版而非当前发布版（因为如果是最新版，容易出现一些奇妙的 bug）。 全部默认下一步进行安装。 Windows 打开命令提示符。Linux 用户右上角关闭本标签页。 后续如提到输入命令，均默认指打开终端进行输入。 输入 node --version，如果得到的版本号与你方才安装的一致，那么 Node.js 就已经成功安装。 Git 与 GitHub安装 Git Git 是一个开源的分布式版本控制系统，由 Linus Torvalds（同时也是 Linux 的作者）为了管理 Linux 开发而开发。简而言之，是一个版本管理工具。譬如设计师设计好了第三版的海报，客户却说还是要第一版吧，这时便可以通过 Git 快速回退到最初的版本。你只需要把每次更改的状态（Git 会自动进行检测，你只要掌握基础的几条命令就可以了）告诉 Git，而不需要每个版本都保存一份压缩包，既方便也能大大节约空间。（当然这主要只对代码文本起作用，因为 Git 的本质是记录各行代码的增减，倘若是像视频、海报这类二进制文件来说便体现不出丝毫优势了。当然想要应对这种场景还有 Git LFS。） 注册 GitHub GitHub 一听便与 Git 有所渊源。Git 在英文中是懒人、饭桶之意。Hub 则是中心、集线器的意思。譬如 USB 集线器就是 USB Hub。所以 GitHub 就是饭桶中心（大雾）。GitHub 是全世界最大的开源项目与代码托管平台，也是众多开发者的交流场所。还是全球最大的同性交友网站。而代码托管本身用到的正是上文提到的 Git 技术。 注册 GitHub 账号。（虽然都是英文，但不必畏惧，也并不会造成使用障碍，只要记得最常用的选项含义即可，以及善用手头的翻译软件。谷歌浏览器的话在页面右击鼠标便有 【翻译成中文】的选项） 注意：注册时的英文用户名将成为你可以使用的免费域名前缀。 登录 GitHub。 为什么要用 GitHub？对于平民玩家来说，在初次尝试建立自己的网站时，也许并不会有闲钱或者说决心来购买自己的服务器与域名。而 GitHub 则提供了 GitHub Pages 这一服务。用户们可以利用这一服务，部署自己的静态站点。 点击右上角的 + -&gt; New repository 新建仓库。 我这里因为已经有同名仓库，所以提示了重复。 仓库名称务必为 你的用户名.github.io，用户名是英文，大小写无所谓，但建议统一小写。（因为你会发现时常切换大小写很麻烦） 为什么必须这个作为仓库名？GitHub Pages 服务的命名规范，同时它也将成为你的专属域名。当然，你也可以购置自己的专属域名并用它来提供内容。 点击 Create repository。 安装HexoHexo GitHub: http://github.com/hexojs/hexo 官方文档（直接参考文档也是一个不错的选择） 为嘛使用 Hexo ？Hexo 是一个快速、简洁而强大的博客框架，基于 Node.js，同样托管于 GitHub 之上。生态中拥有众多插件主题。你可以基于它快速生成一些静态页面。你可以使用别人的各种主题与插件，也可以自己定制开发想要的功能。为什么不是…?其他常用的博客框架还有 WordPress，Typecho，Ghost 等，但这些往往都需要购置自己的服务器，而无法静态化地部署到 GitHub Pages 上。（当然，相应的功能和灵活性也大大提升。）静态化站点还有一个优势就是访问速度往往更快。静态网站生成器还有 Vuepress，Gatsby 等。但这些多是为了写文档而量身定制的，你也可以使用它们，但是相较 Hexo 的博客定位，它们关于博客的插件和主题以及解决办法会少得多。Hexo 提供的功能与 Hugo 几乎都有，（生成大量文件时，甚至比 Hexo 更快）不过它是基于 GO 语言。日后你想对自己的网站进行自定义，即便是 Hugo，你编写前端的交互仍旧需要使用 JavaScript，所以选择基于 JavaScript 的 Hexo 可以降低学习成本。（其实是我找不到好看的hugo主题） 在终端中输入以下命令： npm install hexo-cli -g # 如果安装失败，可能是没有权限，可以尝试头部加上 sudo 重新执行 # sudo npm install hexo-cli -g npm 是随 Node.js 一起被安装的包管理工具，你可以理解成 Node.js 自带的应用商店。install 自然是安装。hexo-cli 则是 hexo 的终端工具，可以帮助你生成一些模版文件，之后再用到。-g 代表的是全局安装。也就是在任何地方都可以使用，否则会只能在安装的目录下使用。 此时，请先通过 cd 进入你本地电脑打算存储网站代码的文件夹目录。（或者右键文件夹 Git Bash Here） cd | DOS 命令cd （LINUXSHELL 命令） 譬如： 注意：这里是你自定义的目录，请不要复制粘贴 # &#39;#&#39; 字符后的文字代表注释，不需要输入 # Windows cd C:\\Users\\YunYou\\Documents\\GitHub\\ # macOS # cd /Users/yunyou/github/ 接下来输入： hexo init 你的名字.github.io hexo 正是因为我们之前安装了 hexo-cli 这一个包，所以我们可以在终端中使用 hexo 这一命令。init 初始化博客的模版文件。后面跟的是你要新建的文件夹，最好和你此前新建的仓库名一致。 # 进入你的博客文件夹 cd 你的名字.github.io # 默认安装所有 `package.json` 文件中提到的包 npm install # 你也可以缩写成 hexo s hexo server server 代表开启本地的 Hexo 服务器，这时你就可以打开浏览器，在地址栏中输入 localhost:4000 就可以看到本地的网页了。 按 Ctrl + C 终端服务器的运行。 至此，基础的模版页面便已经搭建好了。 使用 Hexo 主题Hexo 默认提供的是 hexo-theme-landscape 主题。默认主题样式简单，功能较少。所以大多数人并不会使用默认主题。 这里是别人开发的主题 我只是下载用用 hexo-theme-yun。 如果有人看这篇文章的话，麻烦点击 请去github收藏一下作者的主题 下载 Hexo 主题进入终端（确保路径处于你此前使用 Hexo 初始化好的文件夹目录下，即 xxx.github.io，后简称为 Hexo 目录），输入以下命令。 实际上你也可以直接在 VS Code 中使用终端。 git clone https://github.com/YunYouJun/hexo-theme-yun themes/yun 这里便使用到了我们此前安装的 Git，git clone 即代表克隆（也就是复制的作用）本主题（托管于 GitHub，链接便是主题所在的地址），themes/yun 则代表放在你 Hexo 文件夹下的 themes/yun 文件夹里（没有该文件夹会自动新建）。 编辑 Hexo 配置在你此前通过 Hexo 初始化生成的文件目录下，会存在一个 _config.yml 文件。 yml 是 YAML 文件的后缀名，YAML 是 “YAML Ain’t a Markup Language”（YAML 不是一种标记语言） 的缩写，但它实际上还是一种标记语言。你可以将其理解为存储数据的一种文本格式，这也是其诞生的目的。 如果你听说过 JSON，那你就更能明白它是干什么的了。 它是 Hexo 的配置文件，关于各配置选项的意义你可以查看 配置 | Hexo。 在 _config.yml 中找到 theme 这个字段，将其后的 landscape 修改为 yun。 theme: yun pug 是一种模板引擎，可以渲染为 HTML 字符串。类似的还有 ejs，swig 等，语法和设计理念有所不同。stylus 是一种 CSS 预处理器，可以渲染为 CSS。类似的还有 scss，less，同样只是语法和设计理念有所差异。 由于主题使用了 pug 和 stylus，而 Hexo 自带的一般是 ejs 与 stylus，所以你可能还需要输入以下命令安装渲染器。 npm install hexo-render-pug hexo-renderer-stylus 这时再像此前那般使用 hexo server 重新启动服务器，你就可以看到一个不一样的主题风格的页面了。 自定义主题配置当启动时，会使用主题的默认配置。但这不一定是你想要的。所以你可以对主题进行一些自定义。 主题的配置文件放在 themes/yun/_config.yml 文件中。且慢，你最好不要直接修改主题的默认配置。倘若日后主题升级更新了怎么办吗，难道还要重新配置一遍吗？ 最好的解决方案就是在博客根目录下（不是主题目录）新建 source/_data/yun.yml。（若 source/_data 目录不存在，请新建） 本主题将自定义配置与默认配置进行合并，因此你只需要在 yun.yml 文件中自定义你需要的配置即可，其余仍将自动采用默认配置。 譬如我们需要更换头像。在 yun.yml 中填写。 你可以在 source 文件夹下新建 images 文件夹，用来存储你的图片。也可以使用 SM.MS 等图床工具上传你的图片文件，获取在线链接。 avatar: url: /images/avatar.jpg # 你的头像图片地址 rounded: true opacity: 1 更换主题色彩，比如换成黑色，黑色的十六进制颜色代码是 #000000。 colors: primary: &quot;#000000&quot; 这时你的主题色调就会变为黑色。 这只是一个配置项的简单示例，更多配置你可以参考我的主题文档或直接在 theme/yun/_config.yml 中查看，并根据自己的需要进行配置。 生成静态文件至今我们的工作都是在本地进行，想必你也很想放到线上与小伙伴们分享。这便轮到了 GitHub Pages 的出场，不过 GitHub Pages 只支持纯静态文件。 所以我们需要使用以下命令先来生成站点的静态文件。 # 如果进行多次生成，为了避免受错误缓存影响，最好使用 hexo clean 先清除一遍。 hexo generate # 缩写为 hexo g 此时你的文件夹目录下会出现 public 这个文件夹，里面存放的就是你站点的静态文件。 与远程仓库建立关联接下来我们将本地的仓库与此前在 GitHub 上建立的仓库建立关联。 git init # 初始化 Git 仓库，只需要执行一次即可 在将其部署到 GitHub Pages 上之前，我们最好先建立一个分支。 什么是分支？Git 提供了版本管理功能，其中还有一个分支功能，你现在可以简单地将其理解为平行世界。 你的名字.github.io 部署后，GitHub Pages 将默认使用你的 master 分支作为静态文件部署。所以我们最好新建一个 hexo 分支（命名无所谓）用来存储 Hexo 地源代码，master 分支则用来存储部署后的静态文件。 git checkout -b hexo 这时便成功建立了一个 hexo 分支。（此后的工作都将在 hexo 分支下进行） 你可以通过 git branch -v 来查看当前有哪些分支，使用 git branch 分支名 来切换到对应的分支。 Git 学习笔记 部署为了更方便的部署到 GitHub Pages，Hexo 提供了 hexo-deployer-git 插件。 老规矩，安装。 npm install hexo-deployer-git 在 _config.yml 中配置。 deploy: type: git repo: 你此前新建的仓库的链接 # 比如：https://github.com/zl956973503/zl956973503.github.io branch: master # 默认使用 master 分支 message: Update Hexo Static Content # 你可以自定义此次部署更新的说明 保存，部署！ 第一次可能需要你输入用户名与密码。密码输入的时候不会出现 ***，不要害怕，已经输入进去了。 hexo deploy 等待完成后，打开网址 https://你的名字.github.io 就能看到你的线上网站了。 使用 https，http 可能无法正常打开。HTTPS 是多了安全加密的 HTTP，Chrome 浏览器已经默认会显示 http 链接为不安全。为了安全，建议开启强制 https 跳转。项目地址页面 -&gt; Settings -&gt; Options -&gt; GitHub Pages -&gt; Enforce HTTPS。（翻到下面）此时，http 网址会自动重定向到 https 备份与自动部署我们当前只是将生成的静态文件部署到了云端。 为了以防万一，我们应该将网站的源代码文件也推送到 GitHub 仓库备份。 # 与远程 Git 仓库建立连接，只此一次即可 git remote add origin https://github.com/你的用户名/你的名字.github.io 接下来准备提交，这几句命令将是你以后每次备份所需要输入。 # 添加到缓存区 git add -A git commit -m &quot;这次做了什么更改，简单描述下即可&quot; # 推送至远程仓库 git push # 第一次提交，你可能需设置一下默认提交分支 # git push --set-upstream origin hexo 每次推送都要输入这三条命令，你可能觉得有些麻烦。那么你可以编写 bash 脚本。 譬如，在根目录下新建 update.sh。 # 如果没有消息后缀，默认提交信息为 `:pencil: update content` info=$1 if [&quot;$info&quot; = &quot;&quot;]; then info=&quot;:pencil: update content&quot; fi git add -A git commit -m &quot;$info&quot; git push origin hexo 此后更新的话，只需要在终端执行 sh update.sh 即可。 更新麻烦，每次部署也很麻烦，可以使用持续集成进行自动部署。 什么是持续集成？持续集成是一种软件开发实践。对软件进行自动化构建，以此来发现错误。Travis CI 就是一个线上持续集成服务的提供商。它可以拉取你每次推送到 GitHub 上的代码，然后根据你的要求对其进行构建。我们可以趁机让它自动生成网站静态文件，然后自动帮我们部署。除此之外，你还可以使用 GitHub Actions ，Netlify 等服务。GitHub Actions 相比 Travis 等，自身便拥有仓库的 Token，不再需要额外设置，可以直接使用 secrets.GITHUB_TOKEN。推荐一个专门用来部署 gh-pages 的 Actions actions-gh-pages 关于更多更具体的自动化部署方案和操作步骤，可以参考 ChrAlpha 的 初探无后端静态博客自动化部署方案。 他在文章中详细介绍了 Netlify 、GitHub Actions 和 Travis CI 的部署方法。 你也可以参考 Hexo 的官方文档 将 Hexo 部署到 GitHub Pages 我就不在此画蛇添足。 至此，你的站点便基本搭建完成，此后继续对主题进行自定义吧。 Yun 主题文档 开始写作文章输入以下命令即可新建 xxx.md 文件。 hexo new post xxx md 是 Markdown 的后缀名，是一种简洁方便的文本标记语言。你只需要记住简单的几种语法，就可以快速进行编写。为什么使用 Markdown？首先 Hexo 本身就是将 Markdown 转化为静态的 Html 文件，来方便用户编写文章。Markdown 就好似介于 Word 与 TXT 文本之间。Word 体积大、大部分功能实际上根本用不到，且最后的文档常常带有许多冗余信息。而 TXT 却无法实现加粗、标题、下划线、水平分割线等常用的功能。（这里所说的 TXT 只是一种纯文本格式的代称，实际上 Markdown 也是纯文本文件，不过通过语法和 Markdown 编译器，我们就可以看到一些简单的样式。） 譬如本文就是通过 Markdown 编写。 # 一级标题 ## 二级标题 **加粗文字** 更多语法（虽然说是更多，但是其实也没多少）：Markdown 基本语法 页面你可以新建一些自己的自定义页面。 譬如直接在 Hexo 目录下的 source 文件夹下直接新建 HTML 进行编写。 也可以通过以下命令来新建页面。（当然还是 Markdown，不过也是可以在 Markdown 里写 HTML 的，也会被渲染出来。） hexo new page xxx 说到这里，就不得不提一提本主题的特色功能了。 生成你的老婆列表页面。按一定格式书写即可。见文档。 FAQ如何绑定你的自定义域名？首先，你得有个自己的域名。 可以去 阿里云 购买服务器 并使用 CNAME 解析到 你的名字.github.io。（当然 A 记录直接解析到 GitHub Pages IP 地址也可以。） Managing a custom domain for your GitHub Pages site 在 Hexo 工作目录下 source 文件夹下新建 CNAME 文件（没有后缀名）。 CNAME 即相当于告诉 GitHub 允许将 xxx.github.io 为你的域名提供服务。source 目录下的文件除了特殊的 markdown 会被解析为 html，其余都会原样复制到生成的静态文件夹中。所以你需要在 source 文件夹下建有 CNAME，它会在生成静态文件时，将 CNAME 拷贝到静态文件夹并部署到 master 分支。如果只是在 GitHub 上设置（项目地址页面 -&gt; Settings -&gt; Options -&gt; GitHub Pages -&gt; Custom domain），它会自动添加到 master 分支上，但随后不包含 CNAME 的部署会将其覆盖。 内容填写你的域名即可。 About custom domains and GitHub Pages 结语个人网站同样可以用来做许多事情，你可以将其用来记录生活、回忆、创作、学习笔记、开发经验等（包括作为一个试验平台）。可以与熟悉的人分享，也可以作为另一个世界另一个自己的展示。 多年后，回看起自己当初写下的内容，未尝不是件有趣的事情。 善始者众，善终者寡。 臣闻善作者，不必善成；善始者，不必善终。「史记·乐毅列传」 希望大家能有毅力坚持下去，不忘初心。 永远相信美好的事情即将发生","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"},{"name":"web","slug":"web","permalink":"https://zhoulei.icu/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"进程和线程的简单理解","slug":"进程和线程的简单理解","date":"2020-04-08T16:00:00.000Z","updated":"2020-04-21T02:28:29.744Z","comments":true,"path":"2020/04/09/进程和线程的简单理解/","link":"","permalink":"https://zhoulei.icu/2020/04/09/进程和线程的简单理解/","excerpt":"","text":"抽象类比：单CPU：一台单核处理器计算机 = 一个车间；多CPU：一台多核处理器计算机 = 一座工厂；进程：一个车间 = 一个进程； （即一个运行的程序）多进程：一座工厂可以同时运行多个车间；CPU和进程：单CPU只能同时运行单个进程，多CPU可以同时运行多个进程。线程：车间内一个工人 = 一个线程；进程与线程：一个进程可以包括多个线程。线程间内存共享：车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。内存安全：可是，每个车间容纳大小不同，有的最多只能容纳一个人。车间人满的时候，其他人就进不去了。一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。互斥锁：一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫”互斥锁”–Mutex，防止两个线程同时读写某一块内存区域。信号量：这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。锁和信号量：不难看出，互斥锁是信号量的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。操作系统的资源分配与调度逻辑 以多进程形式，允许多个任务同时运行； 以多线程形式，允许单个任务分成不同的部分运行； 提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。","categories":[{"name":"python","slug":"python","permalink":"https://zhoulei.icu/categories/python/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"},{"name":"web","slug":"web","permalink":"https://zhoulei.icu/tags/web/"}],"keywords":[{"name":"python","slug":"python","permalink":"https://zhoulei.icu/categories/python/"}]},{"title":"Mysql中的锁","slug":"MySql中的锁","date":"2020-04-03T16:00:00.000Z","updated":"2020-04-21T02:29:14.972Z","comments":true,"path":"2020/04/04/MySql中的锁/","link":"","permalink":"https://zhoulei.icu/2020/04/04/MySql中的锁/","excerpt":"","text":"锁分类 按操作划分：DML锁，DDL锁 按锁的粒度划分：表级锁、行级锁、页级锁 按锁级别划分：共享锁、排他锁 按加锁方式划分：自动锁、显示锁 按使用方式划分：乐观锁、悲观锁 乐观锁实现方法 每次获取商品时，不对该商品加锁。 在更新数据的时候需要比较程序中的库存量与数据库中的库存量是否相等，如果相等则进行更新 反之程序重新获取库存量，再次进行比较，直到两个库存量的数值相等才进行数据更新。 #### 乐观锁实现加一操作代码 # 我们可以看到，只有当对数量-1操作时才会加锁，只有当程序中值和数据库中的值相等时才正真执行。 &#39;&#39;&#39; //不加锁 select id,name,stock where id=1; //业务处理 begin; update shop set stock=stock-1 where id=1 and stock=stock; commit; &#39;&#39;&#39; 悲观锁 每次获取商品时，对该商品加排他锁。 也就是在用户A获取获取 id=1 的商品信息时对该行记录加锁，期间其他用户阻塞等待访问该记录。 #### 悲观锁实现加一操作代码 # 我们可以看到，首先通过begin开启一个事物，在获得shop信息和修改数据的整个过程中都对数据加锁，保证了数据的一致性。 &#39;&#39;&#39; begin; select id,name,stock as old_stock from shop where id=1 for update; update shop set stock=stock-1 where id=1 and stock=old_stock; commit &#39;&#39;&#39; 排它锁 排它锁又叫写锁，如果事务T对A加上排它锁，则其它事务都不能对A加任何类型的锁。获准排它锁的事务既能读数据，又能写数据。 用法 ： SELECT … FOR UPDATE 共享锁(share lock) 共享锁又叫读锁，如果事务T对A加上共享锁，则其它事务只能对A再加共享锁，不能加其它锁。 获准共享锁的事务只能读数据，不能写数据。 用法： SELECT … LOCK IN SHARE MODE;","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"},{"name":"web","slug":"web","permalink":"https://zhoulei.icu/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"ORM操作","slug":"ORM操作","date":"2020-04-02T16:00:00.000Z","updated":"2020-04-21T02:29:20.424Z","comments":true,"path":"2020/04/03/ORM操作/","link":"","permalink":"https://zhoulei.icu/2020/04/03/ORM操作/","excerpt":"","text":"Django模型之ORM操作ORM介绍 什么是ORMORM 全拼Object-Relation Mapping. 中文意为 对象-关系映射. 在MVC/MVT设计模式中的Model模块中都包括ORM ORM优势 只需要面向对象编程, 不需要面向数据库编写代码. 对数据库的操作都转化成对类属性和方法的操作.不用编写各种数据库的sql语句. 实现了数据模型与数据库的解耦, 屏蔽了不同数据库操作上的差异. 不在关注用的是mysql、oracle…等.通过简单的配置就可以轻松更换数据库, 而不需要修改代码. ORM劣势相比较直接使用SQL语句操作数据库,有性能损失.根据对象的操作转换成SQL语句,根据查询的结果转化成对象, 在映射过程中有性能损失. ORM和数据库关系：在Django中model是你数据的单一、明确的信息来源。它包含了你存储的数据的重要字段和行为。通常，一个模型（model）映射到一个数据库表. 基本情况： 每个模型都是一个Python类，它是django.db.models.Model的子类。 模型的每个属性都代表一个数据库字段。 ORM操作增加操作 # 通过python manage.py shell 进入到shell下 # 进入shell环境以后，首先导入模型 from polls.models import * # 导入全部模型 from django.utils import timezone # 导入时间模块 # 创建方法一： q = Question(question_text=&quot;什么地方的菜最有特色？&quot;, pub_date=timezone.now()) q.save() # 关联创建，用问题关联创建选项 q.choice_set.create(choice_text=&quot;湖南&quot;) # 创建方法二： q = Question() # 创建实例对象 q.question_text = &quot;什么地方的菜最有特色？&quot; q.pub_date = timeaone.now() q.save() # 创建方法三： Question.objects.create(question_text=&quot;什么地方的菜最有特色？&quot;, pub_date=timezone.now()) # 批量创建，可以提高性能，减少对数据库的访问写入次数 bulk_create() # 批量添加，需要传入的参数是一个列表 Question.objects.bulk_create( [ Question(question_text=&quot;什么地方的菜最有特色？&quot;, pub_date=timezone.now()), Question(question_text=&quot;什么地方的景色最美？&quot;, pub_date=timezone.now())， ] ) 修改操作# 修改方法1： Question.objects.update(question_text = &quot;什么地方最好玩？&quot;) # 修改方法2： q = Question.objects.update(pk=1) q.question = &quot;什么地方最好玩？&quot; q.save() 删除操作# 删除：(先查询到某个queryset对象，然后用删除命令) q = Question.objects.get(id=1) q.delete() 查询操作必会的方法 # 1、 all(): 查询所有结果 question_list = Question.objects.all() # 返回一个queryset集合 # 2、 filter(**kwargs): 它包含了与所给筛选条件相匹配的对象 question_list = Question.objects.filter(pk=1) # 返回一个queryset集合,如果没有查询到，返回一个空集合,不会报错 # 3、 get(**kwargs): 返回与所给筛选条件相匹配的对象，返回结果有且只有一个，如果符合筛选条件的 对象超过一个或者没有都会抛出错误。 question = Question.objects.get(pk=1) # 返回一个queryset对象，并且只会得到一个数据，如果没有查询到，会报DoesNotExist的错误 # 4、 exclude(**kwargs): 它包含了与所给筛选条件不匹配的对象 question = Question.objects.exclude(id__in=[11, 22, 33]) # 筛选id除了11，22，33外的，其它的数据 # 5、 values(*field): 返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系列 model的实例化对象，而是一个可迭代的字典序列 question = Question.objects.values() # 返回结果：[{&quot;id&quot;: 1, &quot;question_name&quot;: &quot;xxxxxxx&quot;}, {&quot;id&quot;: 2, &quot;question_name&quot;: &quot;xxxxxxx&quot;}, ...] # 6、 values_list(*field): 它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序 列 question = Question.objects.values_list() # 返回结果：[(1, &quot;xxxxxxx&quot;), (2, &quot;xxxxxxx&quot;), ....] # 7、 order_by(*field): 对查询结果排序 user_list = User.objects.order_by(&quot;-id&quot;) # “-” 按id降序排列 user_list = User.objects.order_by() # 按id升序排列（默认） # 8、 reverse(): 对查询结果反向排序，请注意reverse()通常只能在具有已定义顺序的QuerySet 上调用(在model类的Meta中指定ordering或调用order_by()方法)。 user = User.objects.all().reverse() # 把查询的结果进行反转 # 9、 distinct(): 从返回结果中剔除重复纪录(如果你查询跨越多个表，可能在计算QuerySet时得到 重复的结果。此时可以使用distinct()，注意只有在PostgreSQL中支持按字段 去重。) Question.objects.all().distinct() # 把结果中重复的记录剔除 # 10、 count(): 返回数据库中匹配查询(QuerySet)的对象数量。 user_count = User.objects.count() # 返回user表中的用户数量 # 11、 first(): 返回第一条记录 User.objects.first() # 12、 last(): 返回最后一条记录 User.objects.last() # 13、 exists(): 如果QuerySet包含数据，就返回True，否则返回False user = User.objects.filter(pk=1).exists() # 返回True 或者False if user: print(&quot;OK&quot;) 查询条件在 ORM 层面，这些查询条件都是使用 field + __ + condition 的方式来使用 # 精确的 等于,如果提供一个None,SQL解析为Null article = Article.objects.get(id__exact=14) article = Article.objects.get(id__exact=None) &#39;&#39;&#39; 对应sql select ... from article where id=14; select ... from article where id IS NULL; &#39;&#39;&#39; # iexact 使用like查询 article = Article.objects.filter(title__iexact=&#39;hello world&#39;) &#39;&#39;&#39; 等价于 select ... from article where title like &#39;hello world&#39; &#39;&#39;&#39; # 包含:contains,区分大小写 articles = Article.objects.filter(title__contains=&#39;hello&#39;) &#39;&#39;&#39; 等价于select ... where title like binary &#39;%hello%&#39;; &#39;&#39;&#39; # icontains 忽略大小写 articles = Article.objects.filter(title__icontains=&#39;hello&#39;) &#39;&#39;&#39; 等价于 select ... where title like &#39;%hello%&#39;; &#39;&#39;&#39; # in 提取那些给定的field的值是否在给定的容器中。容器可以为list、tuple或者任何一个可以迭代的对 象，# 包括QuerySet对象 articles = Article.objects.filter(id__in=[1,2,3]) &#39;&#39;&#39; 等价于 select ... where id in (1,3,4) &#39;&#39;&#39; # 当然也可以传递一个QuerySet对象进去。示例代码如下： inner_qs = Article.objects.filter(title__contains=&#39;hello&#39;) categories = Category.objects.filter(article__in=inner_qs) &#39;&#39;&#39; 等价于:以上代码的意思是获取那些文章标题包含hello的所有分类。 select ...from category where article.id in (select id from article where title like &#39;%hello%&#39;); &#39;&#39;&#39; # gt 大于 articles = Article.objects.filter(id__gt=4) &#39;&#39;&#39; 等价于 select ... where id &gt; 4; &#39;&#39;&#39; # gte 大于等于 # lt 小于 # lte 小于等于 # startswidth 开始,大小写敏感 articles = Article.objects.filter(title__startswith=&#39;hello&#39;) &#39;&#39;&#39; 等价于: select ... where title like &#39;hello%&#39; &#39;&#39;&#39; # istartswidth 大小写不敏感 # endswidth 以**结尾,大小写敏感 articles = Article.objects.filter(title__endswith=&#39;world&#39;) &#39;&#39;&#39; 等价于:select ... where title like &#39;%world&#39;; &#39;&#39;&#39; # iendswidht 以**结尾,忽略大小写 # range 判断某个field的值是否在给定的区间中, 两个范围之间 from django.utils.timezone import make_aware from datetime import datetime start_date = make_aware(datetime(year=2018,month=1,day=1)) end_date = make_aware(datetime(year=2018,month=3,day=29,hour=16)) articles = Article.objects.filter(pub_date__range=(start_date,end_date)) # isnull articles = Article.objects.filter(pub_date__isnull=False) # regex和iregex： 正则 articles = Article.objects.filter(title__regex=r&#39;^hello&#39;) &#39;&#39;&#39; 等价:select ... where title regexp binary &#39;^hello&#39;; &#39;&#39;&#39; &#39;&#39;&#39; 以上代码的意思是提取所有发布时间在2018/1/1到2018/12/12之间的文章。 将翻译成以下的SQL语句： select ... from article where pub_time between &#39;2018-01-01&#39; and &#39;2018-12-12&#39;。 需要注意的是，以上提取数据，不会包含最后一个值。也就是不会包含2018/12/12的文章。 而且另外一个重点，因为我们在settings.py中指定了USE_TZ=True，并且设置了 TIME_ZONE=&#39;Asia/Shanghai&#39;，因此我们在提取数据的时候要使用django.utils.timezone.make_aware 先将datetime.datetime从navie时间转换为aware时间。make_aware会将指定的时间转换为TIME_ZONE中 指定的时区的时间。 &#39;&#39;&#39; 根据关联的表查假如现在有两个 ORM 模型，一个是 Article ，一个是 Category 。代码如下： class Category(models.Model): &quot;&quot;&quot;文章分类表&quot;&quot;&quot; name = models.CharField(max_length=100) class Article(models.Model): &quot;&quot;&quot;文章表&quot;&quot;&quot; title = models.CharField(max_length=100,null=True) category = models.ForeignKey(&quot;Category&quot;,on_delete=models.CASCADE) 比如想要获取文章标题中包含”hello”的所有的分类。那么可以通过以下代码来实现： categories = Category.object.filter(article__title__contains(&quot;hello&quot;)) 聚合函数聚合函数是通过 aggregate 方法来实现的。 Avg ：求平均值。比如想要获取所有图书的价格平均值。那么可以使用以下代码实现 from django.db.models import Avg result = Book.objects.aggregate(Avg(&#39;price&#39;)) print(result) 以上的打印结果是： {&quot;price__avg&quot;:23.0} 其中 price__avg 的结构是根据 field__avg 规则构成的。如果想要修改默认的名字，那么可以将 Avg 赋值给一个关键字参数。示例代码如下： from django.db.models import Avg result = Book.objects.aggregate(my_avg=Avg(&#39;price&#39;)) print(result) 那么以上的结果打印为： {&quot;my_avg&quot;:23} Count ：获取指定的对象的个数。示例代码如下： from django.db.models import Count result = Book.objects.aggregate(book_num=Count(&#39;id&#39;)) 以上的 result 将返回 Book 表中总共有多少本图书。 Count 类中，还有另外一个参数叫做 distinct ，默认是等于 False ，如果是等于 True ，那么将去掉那些重复的值。比如要获取作者表中所有的不重复的邮箱总共有多少个，那么可以通过以下代码来实现： from djang.db.models import Count result = Author.objects.aggregate(count=Count(&#39;email&#39;,distinct=True)) Max 和 Min ：获取指定对象的最大值和最小值。比如想要获取 Author 表中，最大的年龄和最小的年龄分别是多少。那么可以通过以下代码来实现： from django.db.models import Max,Min result = Author.objects.aggregate(Max(&#39;age&#39;),Min(&#39;age&#39;)) 如果最大的年龄是88,最小的年龄是18。那么以上的result将为： {&quot;age__max&quot;:88,&quot;age__min&quot;:18} Sum ：求指定对象的总和。比如要求图书的销售总额。那么可以使用以下代码实现： from djang.db.models import Sum result = Book.objects.annotate(total=Sum(&quot;bookstore__price&quot;)).values(&quot;name&quot;,&quot;total&quot;) 以上的代码 annotate 的意思是给 Book 表在查询的时候添加一个字段叫做 total ，这个字段的数据来源是从 BookStore 模型的 price 的总和而来。 values 方法是只提取 name 和 total 两个字段的值。 更多的聚合函数请参考官方文档：https://docs.djangoproject.com/en/2.0/ref/models/querysets/#aggregation-functions aggregate和annotate的区别： aggregate ：返回使用聚合函数后的字段和值。 annotate ：在原来模型字段的基础之上添加一个使用了聚合函数的字段，并且在使用聚合函数的时候，会使用当前这个模型的主键进行分组（group by）。 比如以上 Sum 的例子，如果使用的是 annotate ，那么将在每条图书的数据上都添加一个字段叫做 total ，计算这本书的销售总额。 而如果使用的是 aggregate ，那么将求所有图书的销售总额。 from django.db import models class Author(models.Model): &quot;&quot;&quot;作者模型&quot;&quot;&quot; name = models.CharField(max_length=100) age = models.IntegerField() email = models.EmailField() class Meta: db_table = &#39;author&#39; class Publisher(models.Model): &quot;&quot;&quot;出版社模型&quot;&quot;&quot; name = models.CharField(max_length=300) class Meta: db_table = &#39;publisher&#39; class Book(models.Model): &quot;&quot;&quot;图书模型&quot;&quot;&quot; name = models.CharField(max_length=300) pages = models.IntegerField() price = models.FloatField() rating = models.FloatField() author = models.ForeignKey(Author,on_delete=models.CASCADE) publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE) class Meta: db_table = &#39;book&#39; class BookOrder(models.Model): &quot;&quot;&quot;图书订单模型&quot;&quot;&quot; book = models.ForeignKey(&quot;Book&quot;,on_delete=models.CASCADE) price = models.FloatField() class Meta: db_table = &#39;book_order&#39; F表达式和Q表达式：F表达式：F表达式 是用来优化 ORM 操作数据库的。比如我们要将公司所有员工的薪水都增加1000元，如果按照正常的流程，应该是先从数据库中提取所有的员工工资到Python内存中，然后使用Python代码在员工工资的基础之上增加1000元，最后再保存到数据库中。这里面涉及的流程就是，首先从数据库中提取数据到Python内存中，然后在Python内存中做完运算，之后再保存到数据库中。示例代码如下： employees = Employee.objects.all() for employee in employees: employee.salary += 1000 employee.save() 而我们的 F表达式 就可以优化这个流程，他可以不需要先把数据从数据库中提取出来，计算完成后再保存回去，他可以直接执行 SQL语句 ，就将员工的工资增加1000元。示例代码如下： from djang.db.models import F Employee.object.update(salary=F(&quot;salary&quot;)+1000) # 直接把sql传输到数据库!!!!! F表达式 并不会马上从数据库中获取数据，而是在生成 SQL 语句的时候，动态的获取传给 F表达式 的值。比如如果想要获取作者中， name 和 email 相同的作者数据。如果不使用 F表达式 ，那么需要使用以下代码来完成： authors = Author.objects.all() for author in authors: if author.name == author.email: print(author) 如果使用 F表达式 ，那么一行代码就可以搞定。示例代码如下： from django.db.models import F authors = Author.objects.filter(name=F(&quot;email&quot;)) # where email = name Q表达式：如果想要实现所有价格高于100元，并且评分达到9.0以上评分的图书。那么可以通过以下代码来实现： books = Book.objects.filter(price__gte=100,rating__gte=9) 以上这个案例是一个并集查询，可以简单的通过传递多个条件进去来实现。 但是如果想要实现一些复杂的查询语句，比如要查询所有价格低于10元，或者是评分低于9分的图书。那就没有办法通过传递多个条件进去实现了。这时候就需要使用 Q表达式 来实现了。示例代码如下： from django.db.models import Q books = Book.objects.filter(Q(price__lte=10) | Q(rating__lte=9)) 以上是进行或运算，当然还可以进行其他的运算，比如有 &amp; 和 ~（非） 等。一些用 Q 表达式的例子如下： from django.db.models import Q # 获取id等于3的图书 books = Book.objects.filter(Q(id=3)) # 获取id等于3，或者名字中包含文字&quot;记&quot;的图书 books = Book.objects.filter(Q(id=3)|Q(name__contains(&quot;记&quot;))) # 获取价格大于100，并且书名中包含&quot;记&quot;的图书 books = Book.objects.filter(Q(price__gte=100)&amp;Q(name__contains(&quot;记&quot;))) # 获取书名包含“记”，但是id不等于3的图书 books = Book.objects.filter(Q(name__contains=&#39;记&#39;) &amp; ~Q(id=3)) 日期# data 针对某些date或者datetime类型的字段。可以指定date的范围。并且这个时间过滤，还可以使用链式调用。示 例代码如下： articles = Article.objects.filter(pub_date__date=date(2018,3,29)) &#39;&#39;&#39; 以上代码的意思是查找时间为2018/3/29这一天发表的所有文章。 将翻译成以下的sql语句： select ... WHERE DATE(CONVERT_TZ(`front_article`.`pub_date`, &#39;UTC&#39;, &#39;Asia/Shanghai&#39;)) = 2018-03-29 注意，因为默认情况下MySQL的表中是没有存储时区相关的信息的。因此我们需要下载一些时区表的文件，然后添 加到Mysql的配置路径中。如果你用的是windows操作系统。那么在 http://dev.mysql.com/downloads/timezones.html下载timezone_2018d_posix.zip - POSIX standard。然后将下载下来的所有文件拷贝到C:\\ProgramData\\MySQL\\MySQL Server 5.7\\Data\\mysql 中，如果提示文件名重复，那么选择覆盖即可。 如果用的是linux或者mac系统，那么在命令行中执行以下命令：mysql_tzinfo_to_sql /usr/share/zoneinfo | mysql -D mysql -u root -p，然后输入密码，从系统中加载时区文件更新到 mysql中。 &#39;&#39;&#39; # year 根据年份进行查找 articles = Article.objects.filter(pub_date__year=2018) articles = Article.objects.filter(pub_date__year__gte=2017) &#39;&#39;&#39; 等价于: select ... where pub_date between &#39;2018-01-01&#39; and &#39;2018-12-31&#39;; select ... where pub_date &gt;= &#39;2017-01-01&#39;; &#39;&#39;&#39; # month 同year,根据月份查 # day 同year,根据日期查 # week_day Django 1.11新增的查找方式。同year，根据星期几进行查找。1表示星期天，7表示星期六，2-6代表的是星期一到星期五。 # time 根据时间查 articles = Article.objects.filter(pub_date__time=datetime.time(12,12,12)); # 以上的代码是获取每一天中12点12分12秒发表的所有文章。 更多的关于时间的过滤，请参考Django官方文档：https://docs.djangoproject.com/en/2.0/ref/models/querysets/#range。","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"},{"name":"web","slug":"web","permalink":"https://zhoulei.icu/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"Django + Vue 跨域","slug":"Django + Vue 跨域","date":"2020-04-01T16:00:00.000Z","updated":"2020-04-21T02:28:46.094Z","comments":true,"path":"2020/04/02/Django + Vue 跨域/","link":"","permalink":"https://zhoulei.icu/2020/04/02/Django + Vue 跨域/","excerpt":"","text":"解决跨域问题——django解决方案1、安装django-core-headers pip install django-core-headers 2、配置settings文件 加入到INSTALLED_APPS下面 INSTALLED_APPS = [ # 第三方框架 &#39;corsheaders&#39;, # 解决跨域问题 ] 配置MIDDLEWARE中间件，放在SessionMiddleware和CommonMiddleware中间。 MIDDLEWARE = [ &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;, &#39;corsheaders.middleware.CorsMiddleware&#39;, # 解决跨域问题，必须放在这个位置，加载顺序 &#39;django.middleware.common.CommonMiddleware&#39;, ] 配置允许跨域访问的域名 CORS_ORIGIN_ALLOW_ALL = True # 解决跨域，配置允许跨域访问的域名，为True时，允许所有的域名 注意：这三项都是在django项目下的seetings中配置的 解决跨域问题——VUE解决方案proxyTable: { &#39;/api&#39;: { //使用&quot;/api&quot;来代替&quot;http://f.apiplus.c&quot; target: &#39;http://127.0.0.1:8000/&#39;, //源地址 changeOrigin: true, //改变源 pathRewrite: { &#39;^/api&#39;: &#39;&#39; //路径重写 } } } 安装axios1、安装axios cnpm install --save axios 2、配制axios,在src文件下的mian.js中配制 import axios from &#39;axios&#39; Vue.prototype.axios = axios 3、axios使用 axios完整写法： this.axios({ method: &#39;post&#39;, url: &#39;/user/12345&#39;, data: { firstName: &#39;Fred&#39;, lastName: &#39;Flintstone&#39; } }).then((res)=&gt;{ console.log(res) }).catch((error)=&gt;{ console.log(error) }); post请求 this.axios.post(&#39;&#39;,{}).then((res)=&gt;{}).catch((error)=&gt;{}) get请求 &lt;script&gt; import Vue from &#39;vue&#39; import axios from &#39;axios&#39; export default{ name: &#39;card&#39;, mounted:function () { //vue页面加载时自动执行 this.send() }, data:{ url_array: [] }, methods:{ send(){ var self = this axios({ method:&#39;get&#39;, url:&#39;http://127.0.0.1:8000/myapp/api_type/&#39; }).then(function(res){ console.log(res.data.li_list); self.url_array = res.data.li_list console.log(self.url_array) }); } } } &lt;/script&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"},{"name":"web","slug":"web","permalink":"https://zhoulei.icu/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"Django简介","slug":"django简介","date":"2020-04-01T16:00:00.000Z","updated":"2020-04-21T02:28:51.183Z","comments":true,"path":"2020/04/02/django简介/","link":"","permalink":"https://zhoulei.icu/2020/04/02/django简介/","excerpt":"","text":"框架定义​ 软件框架（software framework），通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。简而言之，框架就是制定一套规范或者规则（思想），大家（程序员）在该规范或者规则（思想）下工作。或者说使用别人搭好的舞台来做编剧和表演。 Django的历史要了解一个东西，必须知道它的由来 Django 是从真实世界的应用中成长起来的，它是由堪萨斯（Kansas）州 Lawrence 城中的一个网络开发小组编写的。它诞生于 2003 年秋天，那时 Lawrence Journal-World 报纸的程序员 Adrian Holovaty 和 Simon Willison 开始用 Python 来编写程序。 当时他们的 World Online 小组制作并维护当地的几个新闻站点，并在以新闻界特有的快节奏开发环境中逐渐发展。这些站点包括有 LJWorld.com、Lawrence.com 和 KUsports.com，记者（或管理层） 要求增加的特征或整个程序都能在计划时间内快速的被建立，这些时间通常只有几天或几小时。因此，Adrian 和 Simon 开发了一种节省时间的网络程序开发框架，这是在截止时间前能完成程序的唯一途径。 2005 年的夏天，当这个框架开发完成时，它已经用来制作了很多个 World Online 的站点。当时 World Online 小组中的 Jacob Kaplan-Moss 决定把这个框架发布为一个开源软件。 从今往后数年，Django是一个有着数以万计的用户和贡献者，在世界广泛传播的完善开源项目。原来的World Online的两个开发者（Adrian and Jacob）仍然掌握着Django，但是其发展方向受社区团队的影响更大。这些历史都是相关联的，因为她们帮助解释了很重要的两点。 第一，Django最可爱的地方。Django 诞生于新闻网站的环境中，因此它提供很多了特性（如管理后台），非常适合内容类的网站（不要看到这就感到沮丧，尽管Django擅长于动态内容管理系统，但并不表示Django主要的目的就是用来创建动态内容的网站。某些方面特别高效与其他方面不高效是有区别的，Django在其他方面也同样高效。） 第二，Django的起源造就了它的开源社区的文化。因为Django来自于真实世界中的代码，而不是来自于一个科研项目或者商业产品，她主要集中力量来解决Web开发中遇到的问题，同样也是Django的开发者经常遇到的问题。这样，Django每天在现有的基础上进步。框架的开发者对于让开发人员节省时间，编写更加容易维护的程序，同时保证程序运行的效率具有极大的兴趣。无他，开发者动力来源于自己的目标：节省时间，快乐工作。 Django由哪几部分组成 用于进行数据持久化的ORM模块 用于进行URL地址分配的路由模块 用于进行模板页面处理的模板系统 用于进行表单操作的表单模型 用于进行性能突破的缓存系统专业术语解释持久化：数据永久的保存的过程称为数据的持久化ORM：将程序中的对象[Object]和数据库中的表[Relation]建立关联关系[Mapping]的过程称为ORM路由：模拟生活中的路由器，将请求URL地址和对应的函数进行关联的操作称为路由 Django的架构模式关于软件架构模式，我们要从MVC说起 MVC架构模式mvc是由美国的施乐公司（代表产品是打印机、复印机产业）旗下的帕罗奥多研究中心一位程序员发明了smalltalk语言（第二个面向对象的语言），simula67（第一个面向对象的语言） MVC的产生理念：分开。专门的人做专门的事（像公司中各部门一样，不同的部门做着不同的事） MVC的核心思想：解藕。（例如：电脑硬盘坏了，不需要把整个电脑换掉，只需要把硬盘换了，就可以正常使用了。） MVC是一种使用MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式： Model（模型）表示应用程序核心（比如数据库记录列表）。 View（视图）显示数据（数据库记录）。 Controller（控制器）处理输入（写入数据库记录）。 MVT架构模式​ Django在处理的过程中，对于经典的MVC处理模式并不是非常认同，在实际项目开发过程中控制器Controller起到的作用非常的有限，所以Django将控制器部分也进行了封装，但是同时扩展了视图View部分，增加了模板功能实现了前端网页的复用，所以Django的架构模式更加符合MVT处理模式 M:model数据模型 V:View视图 T:Template模板","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"},{"name":"web","slug":"web","permalink":"https://zhoulei.icu/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"创建虚拟环境","slug":"创建虚拟环境","date":"2020-03-31T16:00:00.000Z","updated":"2020-05-28T02:54:44.224Z","comments":true,"path":"2020/04/01/创建虚拟环境/","link":"","permalink":"https://zhoulei.icu/2020/04/01/创建虚拟环境/","excerpt":"","text":"Python 3.4+自带了venv模块，用于创建虚拟环境，每个虚拟环境都可以安装一套独立的第三方模块。 本文在Windows 10上操作。 1、创建一个虚拟环境： D:\\&gt;mkdir test_venv D:\\&gt;cd test_venv D:\\test_venv&gt;python -m venv test 第三行，使用venv模块创建一个名为test的虚拟环境。 执行后，生成了一个test目录，内有1个文件、3个目录： test │ pyvenv.cfg │ ├─Include ├─Lib └─Scripts 2、启用虚拟环境： D:\\test_venv&gt;test\\Scripts\\activate.bat (test) D:\\test_venv&gt; 执行那个activate.bat文件，启用后，提示符前面会出现虚拟环境的名字(test)。 3、用pip给虚拟环境安装模块： 用pip list看一下已有的模块，能看到只有两个Python自带的模块： (test) D:\\test_venv&gt;pip list pip (8.1.1) setuptools (20.10.1) You are using pip version 8.1.1, however version 8.1.2 is available. You should consider upgrading via the &#39;python -m pip install --upgrade pip&#39; command. 提示pip有新版本，按提示用’python -m pip install –upgrade pip’命令更新就好了。 在虚拟环境里，千万别用’pip install –upgrade pip’更新pip，这会破坏pip。 现在，给虚拟环境安装django试试： (test) D:\\test_venv&gt;pip install django 已成功安装django。 4、退出虚拟环境： (test) D:\\test_venv&gt;test\\Scripts\\deactivate.bat D:\\test_venv&gt; 执行deactivate.bat后，退出虚拟环境，此时命令行提示符前的(test)消失了。","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"django","slug":"django","permalink":"https://zhoulei.icu/tags/django/"},{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"个人简历","slug":"个人简历","date":"2020-03-31T16:00:00.000Z","updated":"2020-04-21T02:28:24.254Z","comments":true,"path":"2020/04/01/个人简历/","link":"","permalink":"https://zhoulei.icu/2020/04/01/个人简历/","excerpt":"","text":"个人简历个人基本信息姓 名： 周磊 性 别： 男 联系方式：13935876263 E-mail：zhou956973503@gmail.com 学历：国家开放大学 统招本科 求职意向： python web后端开发 二年的Python开发经验，熟练使用Django框架等后端框架，了解Vue.js的前端框架，熟悉MySQL,redis 数据库，曾参与项目核心模块的开发。优秀的学习能力和团队沟通能力能更快的融入团队开发中去，经常和团队进行技术分享，和团队共同进步。 开发技能后端框架：Django 前端框架：Vue.js 数据库：Mysql，Redis，MongoDB 其他：MarkDown, VS code, PyCharm 工作经历2018.10– 至今 新锐泰乐科技有限公司 Python全栈开发工程师 2017.8–2018.10 思铭博达科技科技有限公司 Python初级开发工程师","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"},{"name":"web","slug":"web","permalink":"https://zhoulei.icu/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]},{"title":"hello-world","slug":"hello-world","date":"2018-12-20T15:13:48.000Z","updated":"2020-04-20T13:43:05.837Z","comments":true,"path":"2018/12/20/hello-world/","link":"","permalink":"https://zhoulei.icu/2018/12/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-11T16:00:00.000Z","updated":"2020-07-06T03:17:58.082Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"https://zhoulei.icu/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://zhoulei.icu/tags/悦读/"},{"name":"web","slug":"web","permalink":"https://zhoulei.icu/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zhoulei.icu/categories/技术/"}]}]}